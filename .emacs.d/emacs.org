Eugene Grigoriev's Dotemacs.

Order is important for some items for compatibility.

* Basics
** The Very Basics
   #+NAME: emacs-very-basic
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq user-mail-address "eugene.grigoriev@gmail.com")
     (setq user-full-name "Eugene Grigoriev")
     ;; (set-face-attribute 'default nil :height 100)
     (setq visible-bell 1)
     (put 'overwrite-mode 'disabled t)
     (global-set-key "\C-c\C-a" 'mark-whole-buffer)
     (global-font-lock-mode t)
     (global-subword-mode t)
     (setq font-lock-maximum-decoration 1)
     (column-number-mode t)
     (global-linum-mode 0)
     (setq linum-delay t
           linum-eager nil)
     (add-hook 'prog-mode-hook (lambda () (linum-mode 1)))
     (global-visual-line-mode)
     (setq-default fill-column 80
                   whitespace-line-column 80)

     (auto-compression-mode t)
     (delete-selection-mode t)
     (setq show-paren-style 'expression)
     (setq-default indent-tabs-mode nil)
     (setq frame-title-format "%b - emacs")
     (setq require-final-newline 't)
     (when (version<= "24.4" emacs-version)
         (global-prettify-symbols-mode 1))
   #+END_SRC

   #+RESULTS: emacs-very-basic
   : t

** Smooth Scrolling
   #+NAME: emacs-smooth-scrolling
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq scroll-margin 1
           scroll-conservatively 10000
           scroll-up-aggressively 0.01
           scroll-down-aggressively 0.01
           auto-window-vscroll nil)
     (setq-default scroll-up-aggressively 0.01
                   scroll-down-aggressively 0.01)
   #+END_SRC

   #+RESULTS: emacs-smooth-scrolling
   : 0.01

** Disable GUI fluff
   #+NAME: emacs-no-fluff
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq initial-scratch-message "")
     (setq inhibit-splash-screen t)
     (add-hook 'window-setup-hook
               (progn
                 (menu-bar-mode -1)
                 (if (display-graphic-p)
                     (progn (tool-bar-mode -1)
                            (scroll-bar-mode -1)))))
   #+END_SRC

   #+RESULTS: emacs-no-fluff
   | (R . t) | (emacs-lisp . t) |

** Transparency
   #+NAME: emacs-transparency
   #+BEGIN_SRC emacs-lisp :tangle yes
     (set-frame-parameter (selected-frame) 'alpha '(90 85))
     (add-to-list 'default-frame-alist '(alpha 90 85))
   #+END_SRC

   #+RESULTS: emacs-transparency

** URL Handling using system
   #+NAME: emacs-url-handling
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq browse-url-browser-function 'browse-url-xdg-open)
   #+END_SRC

   #+RESULTS: emacs-url-handling
   : browse-url-xdg-open

** Default paths
   #+NAME: default-path
   #+BEGIN_SRC emacs-lisp :tangle yes
     (let* ((subdirs '("elisp" "backups" "snippets" "templates" "ac-dict"))
            (fulldirs (mapcar (lambda (d) (sizur/emacs.d d)) subdirs)))
       (dolist (dir fulldirs)
         (when (not (file-exists-p dir))
           (message "Make directory: %s" dir)
           (make-directory dir))))

     (add-to-list 'load-path
                  (sizur/emacs.d "elisp"))

     (defun sizur/emacs.d/elisp (el)
       (expand-file-name el (sizur/emacs.d "elisp")))
   #+END_SRC
   
** Customizations File
   #+NAME: emacs-customizations
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq custom-file (sizur/emacs.d "customizations.el"))
     (when (file-exists-p custom-file)
       (load custom-file))
   #+END_SRC
** Zone
   #+NAME: emacs-zone
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;(require 'zone)
     ;(zone-when-idle 120)
   #+END_SRC
** Tramp
   #+NAME: emacs-tramp-mode
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq tramp-default-method "ssh")
   #+END_SRC

   #+RESULTS: emacs-tramp-mode
   : ssh

* Elisp libs
** Cl
   #+NAME: emacs-cl
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'cl)
     ;(require 'init-support)
   #+END_SRC

   #+RESULTS: emacs-cl

** Dash (List lib)
   #+NAME: emacs-dash
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package dash)
     (use-package dash-functional
       :config
       (dash-enable-font-lock))
   #+END_SRC
** S (String lib)
   String library
   #+NAME: emacs-s
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package s)
   #+END_SRC

   #+RESULTS: emacs-s

** Ht (Hashtable lib)
   #+NAME: emacs-ht
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ht)
   #+END_SRC

   #+RESULTS: emacs-ht

** Loop
   #+NAME: emacs-loop
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package loop)
   #+END_SRC

   #+RESULTS: emacs-loop

** Tco (Tail call optimization)
   #+NAME: emacs-tco
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package tco)
   #+END_SRC

   #+RESULTS: emacs-tco

** Names
   Required by Aggressive Indent
   #+NAME: names
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package names)
   #+END_SRC

   #+RESULTS: names

* Font
  #+NAME: emacs-font
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq preferred-fonts
          '(("Monaco" . 13)
            ("Consolas" . 9)
            ("Source Code Pro" . 10)
            ("Anonymous Pro" . 11)
            ("Inconsolata" . 11)
            ("Bitstream Vera Sans Mono" . 10)
            ("DejaVu Sans Mono" . 10)
            ("Droid Sans Mono" . 10)
            ("Terminus" . 10)
            ))

    (let* ((f (car (-intersection (-map 'car preferred-fonts) (font-family-list))))
           (f (if f
                  (concat f "-" (number-to-string (cdr (assoc f preferred-fonts))))
                nil)))
      (if f
          (progn
            (add-to-list 'default-frame-alist (cons 'font f))
            (set-face-attribute 'default t :font f)
            (set-face-attribute 'default nil :font f)
            (set-frame-font f nil t)
            f)
        nil))
  #+END_SRC

  #+RESULTS: emacs-font
  : Monaco-10

* Autocompletion/Expansion
** Yasnippet
   #+NAME: yasnippet
   #+BEGIN_SRC emacs-lisp :tangle yes  
     (use-package yasnippet
       :config
       (yas-global-mode 1)
       (add-to-list 'yas-snippet-dirs (sizur/emacs.d "snippets"))
       (defun yas/org-very-safe-expand ()
         (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))
       (add-hook 'org-mode-hook
                 (lambda ()
                   (make-variable-buffer-local 'yas/trigger-key)
                   (setq yas/trigger-key [tab])
                   (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
                   (define-key yas/keymap [tab] 'yas/next-field))))
   #+END_SRC

   #+RESULTS: yasnippet
   : t
    
** Company
   #+NAME: emacs-company
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package company
       :config
       (setf company-idle-delay 0
             company-minimum-prefix-length 2
             company-show-numbers t
             company-selection-wrap-around t
             company-dabbrev-ignore-case t
             company-dabbrev-ignore-invisible t
             company-dabbrev-downcase nil)
       (add-to-list 'company-backends 'company-math-symbols-unicode)
       (add-hook 'after-init-hook 'global-company-mode)
       :diminish company-mode)

     ;; (use-package company-quickhelp
     ;;  :config
     ;;  (company-quickhelp-mode 1))
   #+END_SRC

   #+RESULTS: emacs-company
   : t
   
*** Yasnippet Integration
    #+NAME: emacs-company-yasnippet
    #+BEGIN_SRC emacs-lisp :tangle yes
      (when (and (featurep 'yasnippet) (featurep 'company))

        (define-key company-active-map "\t" 'company-yasnippet-or-completion)

        (defun company-yasnippet-or-completion ()
          (interactive)
          (if (yas/expansion-at-point)
              (progn (company-abort)
                     (yas/expand))
            (company-complete-common)))

        (defun yas/expansion-at-point ()
          "Tested with v0.6.1. Extracted from `yas/expand-1'"
          (first (yas/current-key))))
    #+END_SRC
*** Predictive Integration
    #+NAME: emacs-company-predictive
    #+BEGIN_SRC emacs-lisp :tangle yes
      (when (and (featurep 'predictive) (featurep 'company))
        (defun company-predictive (command &optional arg &rest ignored)
          (case command
            (prefix (let* ((text (downcase (word-at-point))))
                      (set-text-properties 0 (length text) nil text)
                      text))
            (candidates (predictive-complete arg))))
        (load "dict-english")
        (add-to-list 'company-backends '(company-predictive)))
    #+END_SRC

    #+RESULTS: emacs-company-predictive
    | (company-predictive) | company-bbdb | company-nxml | company-css | company-eclim | company-semantic | company-clang | company-xcode | company-ropemacs | company-cmake | company-capf | (company-dabbrev-code company-gtags company-etags company-keywords) | company-oddmuse | company-files | company-dabbrev |

** Icicles
   #+NAME: emacs-icicles
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package icicles
       :config
       (icy-mode 1))
   #+END_SRC

   #+RESULTS: emacs-icicles
   : t
** Auto Insertion
   #+NAME: emacs-autoinsertion
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package autoinsert
       :init
       (setq auto-insert-directory (sizur/emacs.d "templates"))
       (setq auto-insert-query nil)
       (add-hook 'find-file-hook 'auto-insert)
       (define-auto-insert "\\.pl$" ["default-perl.pl" ha/autoinsert-yas-expand])
       (auto-insert-mode 1))

     (defun ha/autoinsert-yas-expand ()
            (yas-expand-snippet (buffer-string) (point-min) (point-max)))
   #+END_SRC

   #+RESULTS: emacs-autoinsertion
   : ha/autoinsert-yas-expand

* Parentheses
** Highlight
  #+NAME: emacs-parentheses
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package highlight-parentheses
      :init
      (show-paren-mode t))
  #+END_SRC

  #+RESULTS: emacs-parentheses

** Smartparens
   #+NAME: emacs-smartparens
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package smartparens-config
       :ensure smartparens
       :config
       (require 'smartparens-latex)
       (require 'smartparens-haskell)
       (require 'smartparens-html)
       (smartparens-global-mode 1)
       (add-hook 'emacs-lisp-mode-hook
                 (lambda ()
                   (turn-on-eldoc-mode))))
   #+END_SRC

   #+RESULTS: emacs-smartparens
   : t
** Paredit
   #+NAME: emacs-paredit
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package paredit
       :config
       ;; (add-hook 'emacs-lisp-mode-hook
       ;;           (lambda ()
       ;;             (paredit-mode t)
       ;;             (turn-on-eldoc-mode)
       ;;             (eldoc-add-command
       ;;              'paredit-backward-delete
       ;;              'paredit-close-round)
       ;;             (local-set-key (kbd "RET") 'electrify-return-if-match)
       ;;             (eldoc-add-command 'electrify-return-if-match)
       ;;             (show-paren-mode t)))
       ;; (global-set-key (kbd "M-[") 'paredit-backward-slurp-sexp)
       ;; (global-set-key (kbd "M-{") 'paredit-backward-barf-sexp)
       )
   #+END_SRC

   #+RESULTS: emacs-paredit
   : t
** Cedit
   #+NAME: emacs-cedit
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package cedit
       :config
       (global-set-key (kbd "M-]") 'cedit-or-paredit-slurp)
       (global-set-key (kbd "M-}") 'cedit-or-paredit-barf)
       (global-set-key (kbd "C-;") 'cedit-beginning-of-statement)
       (global-set-key (kbd "C-'") 'cedit-end-of-statement)
       (global-set-key (kbd "C-:") 'cedit-down-block)
       (global-set-key (kbd "C-M-,") 'cedit-up-block-backward)
       (global-set-key (kbd "C-M-.") 'cedit-up-block-forward))
   #+END_SRC

   #+RESULTS: emacs-cedit
   : t

** Paren-Face
   #+NAME: emacs-paren-face
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package paren-face
       :config
       (global-paren-face-mode t))
   #+END_SRC

   #+RESULTS: emacs-paren-face
   : t

** Rainbow-blocks
   #+NAME: elisp-raindbow-blocks
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package rainbow-blocks
       :config
       ;; (global-rainbow-blocks-mode t)
       )
   #+END_SRC

   #+RESULTS: elisp-raindbow-blocks
   : t

** Highlight-stages
   #+NAME: emacs-highlight-stages
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package highlight-stages
       :config
       (highlight-stages-global-mode 1))
   #+END_SRC

   #+RESULTS: emacs-highlight-stages
   : t

* Highlight Indentation
  #+NAME: emacs-highlight-indentation
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package highlight-indentation)
  #+END_SRC

  #+RESULTS: emacs-highlight-indentation

* Origami
  #+NAME: emacs-origami
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package origami
      :config
      (global-origami-mode 1)
      (global-set-key (kbd "C-M->") 'origami-recursively-toggle-node)
      (global-set-key (kbd "C-M-<") 'origami-show-only-node)
      (global-set-key (kbd "C-M-?") 'origami-undo))
  #+END_SRC

  #+RESULTS: emacs-origami
  : t

* Eldoc
  #+NAME: emacs-eldoc
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package eldoc
      :diminish eldoc-mode)
  #+END_SRC

  #+RESULTS: emacs-eldoc
  |   |

* Orgmode
** Basics
   #+NAME: orgmode-basics
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
     (setq org-directory "~/org")
     (global-set-key "\C-cl" 'org-store-link)
     (global-set-key "\C-cc" 'org-capture)
     (global-set-key "\C-ca" 'org-agenda)
     (global-set-key "\C-cb" 'org-iswitchb)
     ;(setq org-startup-indented t) ; bugs in overlay
     (setq org-default-notes-file (concat org-directory "/notes.org"))
     (define-key global-map "\C-cc" 'org-capture)
   #+END_SRC

   #+RESULTS: orgmode-basics
   : browse-url-xdg-open

** Exports
   #+NAME: 
   #+BEGIN_SRC emacs-lisp :tangle yes
     ; your elisp code here
   #+END_SRC

** Captures
   #+NAME: org-capture
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'org-capture-after-finalize-hook
               (lambda () (if (< 1 (length (frames-on-display-list)))
                              (delete-frame))))
     (setq org-capture-templates
           '(
             ("t" "Todo" entry (file+headline "captures.org" "Tasks")
              "* TODO %?\n  %U\n  %i\n  %a")
             ("w" "conkeror-integration" entry (file+headline "captures.org" "Web")
              "* %?\n  Source: %u, %c\n\n  %i\n")
             ("b" "Buy" checkitem (file+headline "captures.org" "Buy"))
             ("j" "Journal" entry (file+datetree "journal.org")
              "* %?\n  Entered on %U\n  %i\n  %a")
             ))
   #+END_SRC

   #+RESULTS: org-capture
   | t | Todo                 | entry     | (file+headline captures.org Tasks) | * TODO %?\n  %U\n  %i\n  %a       |
   | w | conkeror-integration | entry     | (file+headline captures.org Web)   | * %?\n  Source: %u, %c\n\n  %i\n  |
   | b | Buy                  | checkitem | (file+headline captures.org Buy)   |                                   |
   | j | Journal              | entry     | (file+datetree journal.org)        | * %?\n  Entered on %U\n  %i\n  %a |

** Babel
   #+NAME: orgmode-babel
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;(org-confirm-babel-evaluate nil)
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((R . t)
        (emacs-lisp . t)
        (plantuml . t)
        (latex . t)
        (dot . t)
        ))
     (setq org-plantuml-jar-path (sizur/emacs.d "plantuml.jar"))
     (setq org-confirm-babel-evaluate nil)
     (setq org-src-fontify-natively t)
     (setq org-export-htmlize-output-type 'inline-css)
   #+END_SRC

   #+RESULTS: orgmode-babel
   : inline-css

** Org-Reveal-js
   #+NAME: emacs-org-reveal-js
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ox-reveal
       :config
       (setq org-reveal-root
             "https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0"))
   #+END_SRC

   #+RESULTS: emacs-org-reveal-js
   : file:///home/sizur/.emacs.d/src/reveal.js

** Org-Impress-js
   #+NAME: org-impress.js
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ox-impress-js)
   #+END_SRC

   #+RESULTS: org-impress.js
** Ob-Metapost
   #+NAME: emacs-ob-metapost
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'ob-metapost)
   #+END_SRC

   #+RESULTS: emacs-ob-metapost
   : ob-metapost

** Org-Eldoc
   #+NAME: org-eldoc
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'org-eldoc)
     ;; (org-eldoc-hook-setup)
   #+END_SRC

   #+RESULTS: org-eldoc
   : org-eldoc

** Remember
   #+NAME: emacs-org-remember
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package remember
       :config
       (setq remember-annotation-functions '(org-remember-annotation))
       (setq remember-handler-functions '(org-remember-handler))
       (add-hook 'remember-mode-hook 'org-remember-apply-template))
   #+END_SRC
** TaskJuggler
   #+NAME: emacs-taskjuggler
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'ox-taskjuggler)
   #+END_SRC

   #+RESULTS: emacs-taskjuggler
   : ox-taskjuggler

** O-Blog
   #+NAME: emacs-o-blog
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package o-blog)
   #+END_SRC

   #+RESULTS: emacs-o-blog
   : o-blog

** Ob-PlantUML ImageMagick Support
   #+NAME: emacs-ob-plantuml-imagemagick
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'ob-plantuml)
     (require 'ob-latex) ; for convert shell-out
     (require 'advice)

     (defadvice org-babel-execute:plantuml (after org-babel-execute:plantuml:imagemagick)
       (let* ((params (ad-get-arg 1))
              (out-file (cdr (assoc :file params)))
              (imagemagick (cdr (assoc :imagemagick params)))
              (im-in-options (cdr (assoc :iminoptions params)))
              (im-out-options (cdr (assoc :imoutoptions params))))
         (cond (imagemagick
                (org-babel-latex-convert-pdf out-file out-file im-in-options im-out-options)))))

     (ad-enable-advice 'org-babel-execute:plantuml 'after 'org-babel-execute:plantuml:imagemagick)
     (ad-activate 'org-babel-execute:plantuml)
   #+END_SRC

   #+RESULTS: emacs-ob-plantuml-imagemagick
   : org-babel-execute:plantuml

** Graphviz ImageMagick and Notugly Xslt Integration
   #+NAME: emacs-graphviz-notugly
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'ob-dot)
     (require 'ob-latex) ; for convert shell-out
     (require 'advice)

     (defadvice org-babel-execute:dot (around org-babel-execute:dot:notugly)
       (let* ((params (ad-get-arg 1))
              (out-file (cdr (assoc :file params)))
              (out-file-svg (concat (file-name-sans-extension out-file) ".svg"))
              (imagemagick (cdr (assoc :imagemagick params)))
              (im-in-options (cdr (assoc :iminoptions params)))
              (im-out-options (cdr (assoc :imoutoptions params))))
         (if imagemagick
             (progn
               (with-temp-buffer
                 (ad-set-arg 1 (cons (cons :file out-file-svg)
                                     (assq-delete-all :file (copy-alist params))))
                 ad-do-it
                 (let* ((cmd (concat
                              "xsltproc ~/.emacs.d/src/diagram-tools/notugly.xsl "
                              out-file-svg)))
                   (message "Shell command: %s" cmd)
                   (insert (shell-command-to-string cmd)))
                 (write-file out-file-svg))
               (org-babel-latex-convert-pdf out-file-svg out-file im-in-options im-out-options)
               (when (file-exists-p out-file-svg)
                 (delete-file out-file-svg)))
           ad-do-it)))

     (ad-enable-advice 'org-babel-execute:dot 'around 'org-babel-execute:dot:notugly)
     (ad-activate 'org-babel-execute:dot)
   #+END_SRC

   #+RESULTS: emacs-graphviz-notugly
   : org-babel-execute:dot

** Font Size
   #+NAME: emacs-orgmode-font-size
   #+BEGIN_SRC emacs-lisp :tangle yes
     (custom-set-faces
      '(org-level-1 ((t (:inherit outline-1 :height 1.0))))
      '(org-level-2 ((t (:inherit outline-2 :height 1.0))))
      '(org-level-3 ((t (:inherit outline-3 :height 1.0))))
      '(org-level-4 ((t (:inherit outline-4 :height 1.0))))
      '(org-level-5 ((t (:inherit outline-5 :height 1.0))))
      )
   #+END_SRC
* Theme
** Monokai
  #+NAME: emacs-monokai
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package monokai-theme
      :config
      (load-theme 'monokai t))
  #+END_SRC

  #+RESULTS: emacs-monokai
  : t
* Color Identifiers
  #+NAME: emacs-color-identifiers
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package color-identifiers-mode
      :init
      (add-hook 'after-init-hook 'global-color-identifiers-mode)
      :diminish color-identifiers-mode)
  #+END_SRC

  #+RESULTS: emacs-color-identifiers
  |   |

* Highlight Symbol
  #+NAME: emacs-highlight-symbol
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package highlight-symbol
      :init
      (setq highlight-symbol-idle-delay 0)
      (add-hook 'prog-mode-hook (lambda () (highlight-symbol-mode)))
      :diminish highlight-symbol-mode)
  #+END_SRC

  #+RESULTS: emacs-highlight-symbol

* Smart Mode Line
  #+NAME: emacs-smart-modeline
  #+BEGIN_SRC emacs-lisp :tangle yes
    (which-function-mode 1)
    (use-package smart-mode-line-powerline-theme
      :config
      (setq sml/theme 'powerline)
      (sml/setup)
      (rich-minority-mode 1))
  #+END_SRC

  #+RESULTS: emacs-smart-modeline
  : t
* Whitespace Mode
  #+NAME: emacs-whitespace-mode
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package whitespace
      :bind (("C-c T w" . whitespace-mode))
      :config (setq whitespace-line-column nil)
      :diminish whitespace-mode)
  #+END_SRC

  #+RESULTS: emacs-whitespace-mode

* Auto-Fill Mode
  #+NAME: emacs-auto-fill-mode
  #+BEGIN_SRC emacs-lisp :tangle yes
    (global-set-key (kbd "C-c T f") 'auto-fill-mode)
    (add-hook 'org-mode-hook 'turn-on-auto-fill)
    ;; (diminish 'auto-fill-mode)
  #+END_SRC

  #+RESULTS: emacs-auto-fill-mode

* Popwin
  #+NAME: emacs-popwin
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package popwin
      :config
      ;; (popwin-mode 1)
      )
  #+END_SRC

  #+RESULTS: emacs-popwin
  : t

* Guide Key
  #+NAME: emacs-guide-key
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package guide-key
      :config
      (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
      (guide-key-mode 1))
  #+END_SRC

  #+RESULTS: emacs-guide-key
  : t

* Window Management
** Golden Ratio
   #+NAME: emacs-golden-ratio
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package golden-ratio
       :config
       (setq golden-ratio-exclude-modes
             '("ediff-mode"
               "eshell-mode"
               "dired-mode"
               "calendar-mode"
               ))
       (setq golden-ratio-exclude-buffer-names
             '(" *Org tags*"
               " *Org todo*"
               " *Org adenda*"
               "*phi-search*"
               ))
       (golden-ratio-mode 1)
       :diminish golden-ratio-mode)
   #+END_SRC

   #+RESULTS: emacs-golden-ratio
   : t

** Tiling
   #+NAME: emacs-tiling
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package buffer-move
       :config
       (unless (file-exists-p (sizur/emacs.d/elisp "tiling.el"))
         (url-copy-file
          "https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/tiling.el"
          (sizur/emacs.d/elisp "tiling.el")))
       (require 'tiling)

       ;; Windows related operations
       ;; Split & Resize
       (define-key global-map (kbd "C-x |") 'split-window-horizontally)
       (define-key global-map (kbd "C-x _") 'split-window-vertically)
       ;; (define-key global-map (kbd "C-{") 'shrink-window-horizontally)
       ;; (define-key global-map (kbd "C-}") 'enlarge-window-horizontally)
       ;; (define-key global-map (kbd "C-^") 'enlarge-window)
       ;; Navgating: Windmove uses C-<up> etc.
       (define-key global-map (kbd "C-<up>"   )  'windmove-up)
       (define-key global-map (kbd "C-<down>" )  'windmove-down)
       (define-key global-map (kbd "C-<right>" ) 'windmove-right)
       (define-key global-map (kbd "C-<left>")   'windmove-left)
       ;; Swap buffers: M-<up> etc.
       (define-key global-map (kbd "M-<up>"   ) 'buf-move-up)
       (define-key global-map (kbd "M-<down>" ) 'buf-move-down)
       (define-key global-map (kbd "M-<right>") 'buf-move-right)
       (define-key global-map (kbd "M-<left>" ) 'buf-move-left)
       ;; Tile
       (define-key global-map (kbd "C-\\") 'tiling-cycle) ; accepts prefix number
       (define-key global-map (kbd "C-M-<up>") 'tiling-tile-up)
       (define-key global-map (kbd "C-M-<down>") 'tiling-tile-down)
       (define-key global-map (kbd "C-M-<right>") 'tiling-tile-right)
       (define-key global-map (kbd "C-M-<left>") 'tiling-tile-left)
       ;; Another type of representation of same keys, in case your terminal doesn't
       ;; recognize above key-binding. Tip: C-h k C-up etc. to see into what your
       ;; terminal tranlated the key sequence.
       ;; (define-key global-map (kbd "M-[ a"     ) 'windmove-up)
       ;; (define-key global-map (kbd "M-[ b"     ) 'windmove-down)
       ;; (define-key global-map (kbd "M-[ c"     ) 'windmove-right)
       ;; (define-key global-map (kbd "M-[ d"     ) 'windmove-left)
       ;; (define-key global-map (kbd "ESC <up>"   ) 'buf-move-up)
       ;; (define-key global-map (kbd "ESC <down>" ) 'buf-move-down)
       ;; (define-key global-map (kbd "ESC <right>") 'buf-move-right)
       ;; (define-key global-map (kbd "ESC <left>" ) 'buf-move-left)
       ;; (define-key global-map (kbd "ESC M-[ a" ) 'tiling-tile-up)
       ;; (define-key global-map (kbd "ESC M-[ b" ) 'tiling-tile-down)
       ;; (define-key global-map (kbd "ESC M-[ c" ) 'tiling-tile-right)
       ;; (define-key global-map (kbd "ESC M-[ d" ) 'tiling-tile-left)
       )
   #+END_SRC

   #+RESULTS: emacs-tiling
   : t

** Ace Window
   #+NAME: emacs-ace-window
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ace-window
       :config
       (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l ?o))
       (global-set-key (kbd "C-x o") 'ace-window)
       :diminish ace-window-mode)
   #+END_SRC

   #+RESULTS: emacs-ace-window
   : t

** Kpm List
   #+NAME: emacs-kpm-list
   #+BEGIN_SRC emacs-lisp :tangle yes
;;     (use-package kpm-list
;;       :bind ("C-x C-b" . kpm-list))
   #+END_SRC

   #+RESULTS: emacs-kpm-list

* Comments
  #+NAME: emacs-hide-comnt
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package hide-comnt)
  #+END_SRC
  
* Columnize
  select and M-x columnize-strings <ret>

  #+NAME: emacs-columnize
  #+BEGIN_SRC emacs-lisp :tangle yes
    (unless (file-exists-p (sizur/emacs.d/elisp "columnize.el"))
      (url-copy-file
       "https://raw.githubusercontent.com/emacsmirror/columnize/master/columnize.el"
       (sizur/emacs.d/elisp "columnize.el")))
    (require 'columnize)
  #+END_SRC
* Graphviz
  #+NAME: emacs-graphviz
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package graphviz-dot-mode)
  #+END_SRC

  #+RESULTS: emacs-graphviz

* PlantUML
   #+NAME: default-path
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq puml-plantuml-jar-path (sizur/emacs.d "plantuml.jar"))
     (unless (file-exists-p (sizur/emacs.d "plantuml.jar"))
       (url-copy-file
        "https://downloads.sourceforge.net/project/plantuml/plantuml.jar"
        (sizur/emacs.d "plantuml.jar")))
     (use-package puml-mode)
   #+END_SRC

   #+RESULTS: default-path
   : sizur/emacs\.d/elisp
  
* Calfw
  Calendars in ~/calendar should be updated with cron.
  #+NAME: calendar
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package calfw
      :config
      ;; (require 'calfw-cal)
      (require 'calfw-ical)
      (require 'calfw-org)

      (defun my-open-calendar ()
        (interactive)
        (cfw:open-calendar-buffer
         :contents-sources
         (list
          ;; (cfw:org-create-source "Green")  ; orgmode source
          ;; (cfw:cal-create-source "Orange") ; diary source
          (cfw:ical-create-source "main"  "~/calendars/my-main.ics" "IndianRed")
          (cfw:ical-create-source "bdays" "~/calendars/my-birthdays.ics" "Orange")
          (cfw:org-create-source "Green")
          ))))
  #+END_SRC

  #+RESULTS: calendar
  : my-open-calendar

* mu4e
  #+NAME: emacs-mu4e
  #+BEGIN_SRC emacs-lisp :tangle yes
    (if (file-exists-p "~/.mu4e.el")
        (load-file "~/.mu4e.el"))
  #+END_SRC

  #+RESULTS: emacs-mu4e
  : t

* Fancy Narrow
  #+NAME: emacs-fancy-narrow
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package fancy-narrow
      :config
      (defun ha/highlight-block ()
        "Highlights a 'block' in a buffer defined by the first blank
         line before and after the current cursor position. Uses the
         'fancy-narrow' mode to high-light the block."
        (interactive)
        (let (cur beg end)
          (setq cur (point))
          (setq end (or (re-search-forward  "^\s*$" nil t) (point-max)))
          (goto-char cur)
          (setq beg (or (re-search-backward "^\s*$" nil t) (point-min)))
          (fancy-narrow-to-region beg end)
          (goto-char cur)))

      (defun ha/highlight-section (num)
        "If some of the buffer is highlighted with the `fancy-narrow'
         mode, then un-highlight it by calling `fancy-widen'.

         If region is active, call `fancy-narrow-to-region'.

         If NUM is 0, highlight the current block (delimited by blank
         lines). If NUM is positive or negative, highlight that number
         of lines.  Otherwise, called `fancy-narrow-to-defun', to
         highlight current function."
        (interactive "p")
        (cond
         ((fancy-narrow-active-p)  (fancy-widen))
         ((region-active-p)        (fancy-narrow-to-region (region-beginning) (region-end)))
         ((= num 0)                (ha/highlight-block))
         ((= num 1)                (fancy-narrow-to-defun))
         (t                        (progn (ha/expand-region num)
                                          (fancy-narrow-to-region (region-beginning) (region-end))))))

      :bind ("C-M-+" . ha/highlight-section))
  #+END_SRC

  #+RESULTS: emacs-fancy-narrow

* Expand Region
  #+NAME: expand-region
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package expand-region
      :config
      (global-set-key (kbd "M-=") 'er/expand-region))
  #+END_SRC

  #+RESULTS: expand-region
  : t
  
* Region Bindings
  #+NAME: emacs-region-bindings
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package region-bindings-mode
      :config
      (region-bindings-mode-enable)
      (define-key region-bindings-mode-map (kbd "M--") 'mc/mark-all-like-this)
      (define-key region-bindings-mode-map (kbd "M-[") 'mc/mark-previous-like-this)
      (define-key region-bindings-mode-map (kbd "M-]") 'mc/mark-next-like-this))
  #+END_SRC

  #+RESULTS: emacs-region-bindings
  : t

* Multiple Cursors
  #+NAME: emacs-mult-cursor
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package multiple-cursors
      :config
      (global-set-key (kbd "C-c m /") 'mc/edit-lines)
      (global-set-key (kbd "C-c m .") 'mc/mark-next-like-this)
      (global-set-key (kbd "C-c m ,") 'mc/mark-previous-like-this)
      (global-set-key (kbd "C-c m m") 'mc/mark-all-like-this))
  #+END_SRC

  #+RESULTS: emacs-mult-cursor
  : t

* Phi-search
  Incremental Search that works with Multiple Cursors.
  #+NAME: emacs-phi-search
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package phi-search
      :config
      (require 'phi-replace)
      (global-set-key (kbd "C-s") 'phi-search)
      (global-set-key (kbd "C-r") 'phi-search-backward)
      (global-set-key (kbd "M-%") 'phi-replace-query))
  #+END_SRC

  #+RESULTS: emacs-phi-search
  : t

* Smart Movement
  BUGGY! no tangle
  Requires expand-region
  #+NAME: emacs-smart-forward
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package smart-forward
      :config
      ;; (global-set-key (kbd "M-<up>") 'smart-up)
      ;; (global-set-key (kbd "M-<down>") 'smart-down)
      ;; (global-set-key (kbd "M-<left>") 'smart-backward)
      ;;(global-set-key (kbd "M-<right>") 'smart-forward)
      )
  #+END_SRC

  #+RESULTS: emacs-smart-forward
  : t  
* Avy
  #+NAME: emacs-avy
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package avy
      :bind
      ("M-g g"   . avy-goto-line)
      ("C-c j"   . avy-goto-word-1))
  #+END_SRC

  #+RESULTS: emacs-avy

* Smart Scan
  #+NAME: emacs-smartscan
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package smartscan
      :bind ("M-n" . smartscan-symbol-go-forward)
            ("M-p" . smartscan-symbol-go-backward))
  #+END_SRC
* Wrap Region
  #+NAME: emacs-wrap-region
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package wrap-region
      :config
      (wrap-region-global-mode t)
      ;; (add-to-list 'wrap-region-except-modes 'conflicting-mode)
      (wrap-region-add-wrappers
       '(("(" ")")
         ("[" "]")
         ("{" "}")
         ("<" ">")
         ("'" "'")
         ("\"" "\"")
         ("‘" "’"   "q")
         ("“" "”"   "Q")
         ("*" "*"   "b"   org-mode)                 ; bolden
         ("/" "/"   "i"   org-mode)                 ; italics
         ("_" "_"   "u" '(org-mode markdown-mode))  ; underline
         ("=" "="   "c"   org-mode)                 ; code
         ("**" "**" "b"   markdown-mode)            ; bolden
         ("*" "*"   "i"   markdown-mode)            ; italics
         ("`" "`"   "c" '(markdown-mode ruby-mode)) ; code
         ("`" "'"   "c"   lisp-mode)                ; code
         ))
      :diminish wrap-region-mode)
  #+END_SRC

  #+RESULTS: emacs-wrap-region
  : t

* Cucumber
  #+NAME: emacs-cucumber
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package feature-mode)
  #+END_SRC

  #+RESULTS: emacs-cucumber

* Fish
  #+NAME: emacs-fish
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package fish-mode
      :mode "\\.fish\\'"
      :interpreter "fish")
  #+END_SRC

  #+RESULTS: emacs-fish
  
* Yaml
  #+NAME: emacs-yaml
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package yaml-mode
      :mode "\\.yml$" "\\.yaml$")
  #+END_SRC

  #+RESULTS: emacs-yaml

* XML
** Emmet
   #+NAME: emacs-emmet
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package emmet-mode
       :config
       (add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes
       (add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.
       ;; (add-hook 'emmet-mode-hook (lambda () (setq emmet-indent-after-insert nil)))
       ;; (add-hook 'emmet-mode-hook (lambda () (setq emmet-indentation 2))) ;; indent 2 spaces.
       ;; (setq emmet-move-cursor-between-quotes t) ;; default nil
       ;; (setq emmet-move-cursor-after-expanding nil) ;; default t
       )
   #+END_SRC

   #+RESULTS: emacs-emmet
   : t

   #+RESULTS: xpath2xml
   | zencoding-mode |
* Flycheck
  #+NAME: emacs-flycheck
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package flycheck
      :init
      (setq flycheck-gcc-language-standard "c++1z")
      (setq flycheck-clang-language-standard "c++1z")
      (setq flycheck-perl-include-path
            '(
              "../../../.." "../../../../lib" "../../../../CPAN"
              "../../.." "../../../lib" "../../../CPAN"
              "../.." "../../lib" "../../CPAN"
              ".." "../lib" "../CPAN"
              "." "lib" "CPAN"
              ))
      (add-hook 'after-init-hook 'global-flycheck-mode))
  #+END_SRC

  #+RESULTS: emacs-flycheck

* C++
  RTags should come before CMake-IDE
** RTags
   #+NAME: emacs-rtags
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; (add-to-list 'load-path "~/.emacs.d/local/share/emacs/site-lisp/rtags")
     ;; (setq rtags-path "~/.emacs.d/local/bin")
     ;; (require 'rtags)
   #+END_SRC

   #+RESULTS: emacs-rtags
   : rtags
** CMake-IDE
   #+NAME: emacs-cpp
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (executable-find "clang")
       ;; company-clang is used automatically
       (when (executable-find "clang-format")
         (use-package clang-format
           :config
           (add-hook 'c-mode-common-hook
                     (lambda ()
                       (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'javascript-mode)
                         (when (featurep 'flycheck)
                           ;; (setq flycheck-gcc-language-standard "c++14")
                           ;; (setq flycheck-clang-language-standard "c++14")
                           (flycheck-mode 1))
                         (define-key c++-mode-map [C-M-tab] 'clang-format-region)
                         (define-key c++-mode-map [C-M-S-tab] 'clang-format-buffer)
                         (define-key c++-mode-map [C-M-iso-lefttab] 'clang-format-buffer))))
           (use-package cmake-ide
             :config
             (cmake-ide-setup)))))

     ;; ;; not working correctly for now
     ;; (when (executable-find "ctags")
     ;;   (add-to-list 'load-path "~/.emacs.d/src/ggtags")
     ;;   (require 'ggtags)
     ;;   (add-hook 'c-mode-common-hook
     ;;             (lambda ()
     ;;               (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'cperl-mode)
     ;;                 (ggtags-mode 1))))
     ;;   (define-key ggtags-mode-map (kbd "C-c g s") 'ggtags-find-other-symbol)
     ;;   (define-key ggtags-mode-map (kbd "C-c g h") 'ggtags-view-tag-history)
     ;;   (define-key ggtags-mode-map (kbd "C-c g r") 'ggtags-find-reference)
     ;;   (define-key ggtags-mode-map (kbd "C-c g f") 'ggtags-find-file)
     ;;   (define-key ggtags-mode-map (kbd "C-c g c") 'ggtags-create-tags)
     ;;   (define-key ggtags-mode-map (kbd "C-c g u") 'ggtags-update-tags)
     ;;   (define-key ggtags-mode-map (kbd "M-,") 'pop-tag-mark))
   #+END_SRC

   #+RESULTS: emacs-cpp
   : t

* Haskell
  #+NAME: haskell
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package haskell-mode
      :mode "\\.hs\\'")
  #+END_SRC

  #+RESULTS: haskell
  | turn-on-haskell-indentation | turn-on-haskell-doc-mode |
  
* Perl
  #+NAME: perl
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package anything
      :config
      (use-package perl-completion
        :config
        (defalias 'perl-mode 'cperl-mode)
        (unless (file-exists-p (sizur/emacs.d/elisp "perltidy.el"))
          (url-copy-file
           "https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/perltidy.el"
           (sizur/emacs.d/elisp "perltidy.el")))
        (require 'perltidy)
        (eval-after-load 'cperl-mode
          '(define-key cperl-mode-map (kbd "C-c p") 'perltidy-dwim))
        (add-hook 'cperl-mode-hook
                  (lambda ()
                    (when (featurep 'flycheck)
                      (flycheck-mode 1))
                    (perl-completion-mode t)
                    (local-unset-key (kbd "{"))
                    ))))
  #+END_SRC

  #+RESULTS: perl
  : t
* OCaml
** Tuareg
   #+NAME: emacs-tuareg
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package tuareg
       :mode ("\\.eliom$" . tuareg-mode))
   #+END_SRC

   #+RESULTS: emacs-tuareg

** Opam
   #+NAME: emacs-opam
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (executable-find "opam")
       (setq opam-share (substring (shell-command-to-string
                                    "opam config var share 2> /dev/null") 0 -1))
       (add-to-list 'load-path (concat opam-share "/emacs/site-lisp"))
       (provide 'opam-executable-integration))
   #+END_SRC

   #+RESULTS: emacs-opam
   : opam-executable-integration

** Merlin
   #+NAME: emacs-merlin
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (featurep 'opam-executable-integration)
       (use-package merlin
         :config
         (add-hook 'tuareg-mode-hook 'merlin-mode)
         (add-hook 'caml-mode-hook 'merlin-mode)
         (setq merlin-command 'opam)))
   #+END_SRC

*** Company Integration
    #+NAME: emacs-merlin-company
    #+BEGIN_SRC emacs-lisp :tangle yes
      (when (and (featurep 'merlin) (featurep 'company))
        (add-to-list 'company-backends 'merlin-company-backend)
        (add-hook 'merlin-mode-hook 'company-mode))
    #+END_SRC
    
* Racket
  Order important
** Geiser
   #+NAME: emacs-geiser
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package geiser
       :config
       (add-hook 'geiser-mode-hook
                 (lambda ()
                   (paredit-mode t)
                   (local-set-key (kbd "RET") 'electrify-return-if-match)
                   (show-paren-mode t))))
   #+END_SRC

   #+RESULTS: emacs-geiser
   : t

** Quack
   #+NAME: emacs-quack
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package quack
       :mode ("\\.rkt\\'" . quack-mode))
   #+END_SRC

   #+RESULTS: emacs-quack

* Lua
  #+NAME: emacs-lua
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package lua-mode
      :mode "\\.lua$"
      :interpreter "lua")
  #+END_SRC

  #+RESULTS: emacs-lua

* Rust
  #+NAME: emacs-rust
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package rust-mode
      :mode "\\.rs$")
  #+END_SRC

  #+RESULTS: emacs-rust

* Coq
  #+NAME: emacs-coq
  #+BEGIN_SRC emacs-lisp :tangle yes
    (when (and (executable-find "coqtop")
               (executable-find "tar"))
      (unless (file-exists-p (sizur/emacs.d "ProofGeneral"))
        (url-copy-file
         "http://proofgeneral.inf.ed.ac.uk/releases/ProofGeneral-latest.tgz"
         (sizur/emacs.d "ProofGeneral-latest.tgz")
         t)
        (shell-command (concat "tar zxvf "
                               (sizur/emacs.d "ProofGeneral-latest.tgz")
                               " -C " sizur/emacs.d)))
      (load-file (sizur/emacs.d "ProofGeneral/generic/proof-site.el"))
      (eval-after-load 'coq
        '(setq coq-prog-args
               `("-emacs-U"
                 "-R"
                 ,(expand-file-name
                   "~/.emacs.d/src/cpdt/src")
                 "Cpdt"))))
  #+END_SRC

  #+RESULTS: emacs-coq
  | -emacs-U | -R | ~/.emacs.d/src/cpdt/src | Cpdt |

* Magit
  #+NAME: emacs-magit
  #+BEGIN_SRC emacs-lisp :tangle yes
    (when (executable-find "git")
      (use-package magit))
  #+END_SRC
  
* String Edit
  #+NAME: emacs-string-edit
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package string-edit)
    ;string-edit-at-point
  #+END_SRC

  #+RESULTS: emacs-string-edit

* Ledger
  #+NAME: emacs-ledger
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ledger-mode
      :mode "\\.ledger$")
  #+END_SRC

  #+RESULTS: emacs-ledger

* AUCTeX
  #+NAME: auctex
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package tex-site
      :ensure auctex
      :config
      (setq TeX-auto-save t)
      (setq TeX-parse-self t)
      (setq-default TeX-master nil)
      (add-hook 'LaTeX-mode-hook 'visual-line-mode)
      (add-hook 'LaTeX-mode-hook 'flyspell-mode)
      (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
      (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
      (setq reftex-plug-into-AUCTeX t)
      (setq TeX-PDF-mode t))
  #+END_SRC

  #+RESULTS: auctex
  : t

* Crontab
  #+NAME: emacs-crontab-mode
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package crontab-mode
      :mode "\\.cron\\(tab\\)?\\'" "cron\\(tab\\)?\\.")
  #+END_SRC

  #+RESULTS: emacs-crontab-mode

* UndoTree
  #+NAME: emacs-undotree
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package undo-tree
      :config
      (global-undo-tree-mode 1)
      (global-set-key (kbd "C-z") 'undo)
      (global-set-key (kbd "C-M-z") 'redo)
      :diminish undo-tree-mode)
  #+END_SRC

  #+RESULTS: emacs-undotree
  : t

* Aggressive Indent
  #+NAME: emacs-aggressive-indent
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package aggressive-indent
      :config
      ;; (global-aggressive-indent-mode nil)
      (add-to-list 'aggressive-indent-excluded-modes 'html-mode))
  #+END_SRC

  #+RESULTS: emacs-aggressive-indent
  : t

* Markdown
  #+NAME: emacs-markdown
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package markdown-mode
      :mode "\\.md\\'" "\\.markdown\\'")
  #+END_SRC

  #+RESULTS: emacs-markdown

* Relative Line Numbers
  #+NAME: emacs-relinum
  #+BEGIN_SRC emacs-lisp :tangle no
    (add-to-list 'load-path "~/.emacs.d/src/linum-relative")
    (require 'linum-relative)
    (linum-relative-toggle) ;; turn off by default

    (defun call-macro-linum (arg)
      "blablah"
      (interactive "nTimes: ")
      (kmacro-end-and-call-macro arg))

    (defmacro with-linum-relative (&rest body)
      (let ((linum-format-current (make-symbol "linum-format-current")))
        `(let ((,linum-format-current linum-format))
           (setq linum-format 'linum-relative)
           (linum-update (current-buffer))
           (unwind-protect (progn ,@body)
             (setq linum-format ,linum-format-current)))))

    (defun call-macro-linum-wrap ()
      (interactive)
      (with-linum-relative
       (call-interactively 'call-macro-linum)))

    (global-set-key (kbd "C-x E")
                    'call-macro-linum-wrap)       
  #+END_SRC

  #+RESULTS: emacs-relinum
  : call-macro-linum-wrap

* Key Chord
  #+NAME: emacs-key-Chord
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package key-chord
      :config
      (key-chord-mode 1))
  #+END_SRC

  #+RESULTS: emacs-key-Chord
  : t

* Hydra
  #+NAME: emacs-hydra
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package hydra)
  #+END_SRC

  #+RESULTS: emacs-hydra

** Scale Text
   #+NAME: emacs-scale-text
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (featurep 'hydra)
       (key-chord-define-global
        "-="
        (defhydra hydra-zoom ()
          "zoom"
          ("=" text-scale-increase "in")
          ("-" text-scale-decrease "out"))))
   #+END_SRC

   #+RESULTS: emacs-scale-text
   : hydra-zoom/body

** Move Text
   #+NAME: emacs-hydra-move-text
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package move-text
       :config
       (when (featurep 'hydra)
         (key-chord-define-global
          "ws"
          (defhydra hydra-move-text ()
            "Move text"
            ("w" move-text-up "up")
            ("s" move-text-down "down")))))
   #+END_SRC

   #+RESULTS: emacs-hydra-move-text
   : t

** Org clock
   #+NAME: emacs-org-clock
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (featurep 'hydra)
       (key-chord-define-global
        "wc"
        (defhydra hydra-org-clock (:color blue :hint nil)
          "
     Clock   In/out^     ^Edit^   ^Summary     (_?_)
     -----------------------------------------
             _i_n         _e_dit   _g_oto entry
             _c_ontinue   _q_uit   _d_isplay
             _o_ut        ^ ^      _r_eport
           "
          ("i" org-clock-in)
          ("o" org-clock-out)
          ("c" org-clock-in-last)
          ("e" org-clock-modify-effort-estimate)
          ("q" org-clock-cancel)
          ("g" org-clock-goto)
          ("d" org-clock-display)
          ("r" org-clock-report)
          ("?" (org-info "Clocking commands")))))
   #+END_SRC

   #+RESULTS: emacs-org-clock
   : hydra-org-clock/body

** Smartparens
   #+NAME: emacs-hydra-smartparens
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (and (featurep 'smartparens)
                (featurep 'hydra))
       (key-chord-define-global
        "90"
        (defhydra hydra-learn-sp (:hint nil)
          "
       _B_ backward-sexp            -----
       _F_ forward-sexp               _s_ splice-sexp
       _L_ backward-down-sexp         _df_ splice-sexp-killing-forward
       _H_ backward-up-sexp           _db_ splice-sexp-killing-backward
     ^^------                         _da_ splice-sexp-killing-around
       _k_ down-sexp                -----
       _j_ up-sexp                    _C-s_ select-next-thing-exchange
     -^^-----                         _C-p_ select-previous-thing
       _n_ next-sexp                  _C-n_ select-next-thing
       _p_ previous-sexp            -----
       _a_ beginning-of-sexp          _C-f_ forward-symbol
       _z_ end-of-sexp                _C-b_ backward-symbol
     --^^-                          -----
       _t_ transpose-sexp             _c_ convolute-sexp
     -^^--                            _g_ absorb-sexp
       _x_ delete-char                _q_ emit-sexp
       _dw_ kill-word               -----
       _dd_ kill-sexp                 _,b_ extract-before-sexp
     -^^--                            _,a_ extract-after-sexp
       _S_ unwrap-sexp              -----
     -^^--                            _AP_ add-to-previous-sexp
       _C-h_ forward-slurp-sexp       _AN_ add-to-next-sexp
       _C-l_ forward-barf-sexp      -----
       _C-S-h_ backward-slurp-sexp    _ join-sexp
       _C-S-l_ backward-barf-sexp     _|_ split-sexp
     "
          ;; TODO: Use () and [] - + * | <space>
          ("B" sp-backward-sexp );; similiar to VIM b
          ("F" sp-forward-sexp );; similar to VIM f
          ;;
          ("L" sp-backward-down-sexp )
          ("H" sp-backward-up-sexp )
          ;;
          ("k" sp-down-sexp ) ; root - towards the root
          ("j" sp-up-sexp )
          ;;
          ("n" sp-next-sexp )
          ("p" sp-previous-sexp )
          ;; a..z
          ("a" sp-beginning-of-sexp )
          ("z" sp-end-of-sexp )
          ;;
          ("t" sp-transpose-sexp )
          ;;
          ("x" sp-delete-char )
          ("dw" sp-kill-word )
          ;;("ds" sp-kill-symbol ) ;; Prefer kill-sexp
          ("dd" sp-kill-sexp )
          ;;("yy" sp-copy-sexp ) ;; Don't like it. Pref visual selection
          ;;
          ("S" sp-unwrap-sexp ) ;; Strip!
          ;;("wh" sp-backward-unwrap-sexp ) ;; Too similar to above
          ;;
          ("C-h" sp-forward-slurp-sexp )
          ("C-l" sp-forward-barf-sexp )
          ("C-S-h" sp-backward-slurp-sexp )
          ("C-S-l" sp-backward-barf-sexp )
          ;;
          ;;("C-[" (bind (sp-wrap-with-pair "[")) ) ;;FIXME
          ;;("C-(" (bind (sp-wrap-with-pair "(")) )
          ;;
          ("s" sp-splice-sexp )
          ("df" sp-splice-sexp-killing-forward )
          ("db" sp-splice-sexp-killing-backward )
          ("da" sp-splice-sexp-killing-around )
          ;;
          ("C-s" sp-select-next-thing-exchange )
          ("C-p" sp-select-previous-thing )
          ("C-n" sp-select-next-thing )
          ;;
          ("C-f" sp-forward-symbol )
          ("C-b" sp-backward-symbol )
          ;;
          ;;("C-t" sp-prefix-tag-object)
          ;;("H-p" sp-prefix-pair-object)
          ("c" sp-convolute-sexp )
          ("g" sp-absorb-sexp )
          ("q" sp-emit-sexp )
          ;;
          (",b" sp-extract-before-sexp )
          (",a" sp-extract-after-sexp )
          ;;
          ("AP" sp-add-to-previous-sexp );; Difference to slurp?
          ("AN" sp-add-to-next-sexp )
          ;;
          ("_" sp-join-sexp ) ;;Good
          ("|" sp-split-sexp ))))
   #+END_SRC

   #+RESULTS: emacs-hydra-smartparens
   : hydra-learn-sp/body

** Origami
   #+NAME: emacs-hydra-origami
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (and (featurep 'origami)
                (featurep 'hydra))
       (key-chord-define-global
        ",."
        (defhydra hydra-folding (:color red)
          "
       _o_pen node    _n_ext fold       toggle _f_orward
       _c_lose node   _p_revious fold   toggle _a_ll
       "
          ("o" origami-open-node)
          ("c" origami-close-node)
          ("n" origami-next-fold)
          ("p" origami-previous-fold)
          ("f" origami-forward-toggle-node)
          ("a" origami-toggle-all-nodes))))
   #+END_SRC

   #+RESULTS: emacs-hydra-origami
   : hydra-folding/body

* CMake
  #+NAME: emacs-cmake
  #+BEGIN_SRC emacs-lisp :tangle yes
    (unless (file-exists-p (sizur/emacs.d/elisp "cmake-mode.el"))
      (url-copy-file
       "https://raw.githubusercontent.com/Kitware/CMake/master/Auxiliary/cmake-mode.el"
       (sizur/emacs.d/elisp "cmake-mode.el")))
    (require 'cmake-mode)
    (use-package cmake-font-lock
      :config
      (autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)
      (add-hook 'cmake-mode-hook 'cmake-font-lock-activate))
    (use-package cmake-project
      :config
      (defun maybe-cmake-project-hook ()
        (if (file-exists-p "CMakeLists.txt") (cmake-project-mode)))
      (add-hook 'c-mode-hook 'maybe-cmake-project-hook)
      (add-hook 'c++-mode-hook 'maybe-cmake-project-hook))
  #+END_SRC

  #+RESULTS: emacs-cmake
  : t

* Sublimity
  #+NAME: emacs-sublime
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package sublimity
      :config
      (require 'sublimity-scroll)
      (require 'sublimity-map)
      (require 'sublimity-attractive)
      ;; (sublimity-mode 1)
      )
  #+END_SRC

  #+RESULTS: emacs-sublime
  : t

* Phi-grep
  #+NAME: emacs-phi-grep
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package phi-grep)
  #+END_SRC

  #+RESULTS: emacs-phi-grep

* Definitions
** Eval elips anywhere and replace with result
   #+NAME: eval-and-replace
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun eval-and-replace ()
       "Replace the preceding sexp with its value."
       (interactive)
       (backward-kill-sexp)
       (condition-case nil
           (prin1 (eval (read (current-kill 0)))
                  (current-buffer))
         (error (message "Invalid expression")
                (insert (current-kill 0)))))
     (global-set-key (kbd "C-x C-M-e") 'eval-and-replace)
   #+END_SRC

   #+RESULTS: eval-and-replace
   : eval-and-replace

** Kill file
   #+NAME: kill-file
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun delete-current-buffer-file ()
       "Removes file connected to current buffer and kills buffer."
       (interactive)
       (let ((filename (buffer-file-name))
             (buffer (current-buffer))
             (name (buffer-name)))
         (if (not (and filename (file-exists-p filename)))
             (ido-kill-buffer)
           (when (yes-or-no-p "Are you sure you want to remove this file? ")
             (delete-file filename)
             (kill-buffer buffer)
             (message "File '%s' successfully removed" filename)))))
     (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)
   #+END_SRC

   #+RESULTS: kill-file
   : delete-current-buffer-file

** Rename file
   #+NAME: rename-file
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun rename-current-buffer-file ()
       "Renames current buffer and file it is visiting."
       (interactive)
       (let ((name (buffer-name))
             (filename (buffer-file-name)))
         (if (not (and filename (file-exists-p filename)))
             (error "Buffer '%s' is not visiting a file!" name)
           (let ((new-name (read-file-name "New name: " filename)))
             (if (get-buffer new-name)
                 (error "A buffer named '%s' already exists!" new-name)
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)
               (message "File '%s' successfully renamed to '%s'"
                        name (file-name-nondirectory new-name)))))))
     (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)
   #+END_SRC

   #+RESULTS: rename-file
   : rename-current-buffer-file

** Transpose Lines
   #+NAME: transpose-lines
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun move-line-down ()
       (interactive)
       (let ((col (current-column)))
         (save-excursion
           (forward-line)
           (transpose-lines 1))
         (forward-line)
         (move-to-column col)))
     (defun move-line-up ()
       (interactive)
       (let ((col (current-column)))
         (save-excursion
           (forward-line)
           (transpose-lines -1))
         (move-to-column col)))
     (global-set-key (kbd "<C-S-down>") 'move-line-down)
     (global-set-key (kbd "<C-S-up>") 'move-line-up)
   #+END_SRC

   #+RESULTS: transpose-lines
   : move-line-up
   
** Open Line (above or below)
   #+NAME: open-line
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun open-line-below ()
       (interactive)
       (end-of-line)
       (newline)
       (indent-for-tab-command))
     (defun open-line-above ()
       (interactive)
       (beginning-of-line)
       (newline)
       (forward-line -1)
       (indent-for-tab-command))
     (global-set-key (kbd "<C-return>") 'open-line-below)
     (global-set-key (kbd "<C-S-return>") 'open-line-above)
   #+END_SRC

   #+RESULTS: open-line
   : open-line-above

** TODO Relative Line Numbers
   TODO: make it contextual to C-u or macros

   #+NAME: linum-relative
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; (setq linum-last-pos 0) ; needed during sturtup

     ;; (defadvice linum-update (before linum-relativenumber-linum-update activate)
     ;;   (setq linum-last-pos (line-number-at-pos)))

     ;; (defun linum-relativenumber-format (line-number)
     ;;   (let ((diff (abs (- line-number linum-last-pos)))
     ;;         (w (length (number-to-string
     ;;                     (count-lines (point-min) (point-max))))))
     ;;     (concat (format "%d " line-number)
     ;;             (format (concat "%" (number-to-string
     ;;                                  (+ w (- w (length (number-to-string line-number))))) "d ")
     ;;                     diff))))

     ;; (defun goto-line-with-feedback ()
     ;;   "Show line numbers temporarily, while prompting for the line number input"
     ;;   (interactive)
     ;;   (unwind-protect
     ;;       (progn
     ;;         (linum-mode 1)
     ;;         (goto-line (read-number "Goto line: ")))
     ;;     (linum-mode -1)))

     ;; ;(global-set-key [remap goto-line] 'goto-line-with-feedback)
     ;; (setq linum-format 'linum-relativenumber-format)
   #+END_SRC

   #+RESULTS: linum-relative
   : linum-relativenumber-format

** Don't kill emacs by accident
   #+NAME: emacs-no-kill
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun dont-kill-emacs ()
       (interactive)
       (error (substitute-command-keys "To exit emacs: \\[kill-emacs]")))
     (global-set-key "\C-x\C-c" 'dont-kill-emacs)
     (global-set-key (kbd "C-x r q") 'save-buffers-kill-terminal)
   #+END_SRC

   #+RESULTS: emacs-no-kill
   : save-buffers-kill-terminal

** Backups
   #+NAME: backups
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq vc-make-backup-files t)
     (setq backup-directory-alist
           `(("." . ,(expand-file-name
                      (concat user-emacs-directory ".backups")))))
   #+END_SRC

   #+RESULTS: backups
   | (. . /home/sizur/.emacs.d/.backups) |
   
** Remember position
   #+NAME: remem-pos
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'saveplace)
     (setq-default save-place t)
     (setq save-place-file (expand-file-name ".places" user-emacs-directory))
   #+END_SRC

   #+RESULTS: remem-pos
   : /home/sizur/.emacs.d/.places  
* Autoload at start
  #+NAME: emacs-at-start
  #+BEGIN_SRC emacs-lisp :tangle yes
    (server-start)
    (require 'org-protocol)
    (org-agenda-list)
  #+END_SRC

  #+RESULTS: emacs-at-start
