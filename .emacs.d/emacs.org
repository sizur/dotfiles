Eugene Grigoriev's Dotemacs.

Order is important for some items for compatibility.

* Basics
** The Very Basics
   #+NAME: emacs-very-basic
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq user-mail-address "eugene.grigoriev@gmail.com")
     (setq user-full-name "Eugene Grigoriev")
     ;; (set-face-attribute 'default nil :height 100)
     (setq visible-bell 1)
     (put 'overwrite-mode 'disabled t)
     (global-set-key "\C-c\C-a" 'mark-whole-buffer)
     (global-font-lock-mode t)
     (global-subword-mode t)
     (setq font-lock-maximum-decoration 1)
     (column-number-mode t)
     (global-linum-mode 0)
     (setq linum-delay t
           linum-eager nil)
     (add-hook 'prog-mode-hook (lambda () (linum-mode 1)))
     (global-visual-line-mode)
     (setq-default fill-column 80
                   whitespace-line-column 80)

     (auto-compression-mode t)
     (delete-selection-mode t)
     (setq show-paren-style 'expression)
     (setq-default indent-tabs-mode nil)
     (setq frame-title-format "%b - emacs")
     (setq require-final-newline 't)
     (when (version<= "24.4" emacs-version)
         (global-prettify-symbols-mode 1))
   #+END_SRC

   #+RESULTS: emacs-very-basic
   : t

** Smooth Scrolling
   #+NAME: emacs-smooth-scrolling
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq scroll-margin 1
           scroll-conservatively 10000
           scroll-up-aggressively 0.01
           scroll-down-aggressively 0.01
           auto-window-vscroll nil)
     (setq-default scroll-up-aggressively 0.01
                   scroll-down-aggressively 0.01)
   #+END_SRC

   #+RESULTS: emacs-smooth-scrolling
   : 0.01

** Disable GUI fluff
   #+NAME: emacs-no-fluff
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq inhibit-splash-screen t)
     (add-hook 'window-setup-hook
               (progn
                 (menu-bar-mode -1)
                 (if (display-graphic-p)
                     (progn (tool-bar-mode -1)
                            (scroll-bar-mode -1)))))
   #+END_SRC

   #+RESULTS: emacs-no-fluff
   | (R . t) | (emacs-lisp . t) |

** Transparency
   #+NAME: emacs-transparency
   #+BEGIN_SRC emacs-lisp :tangle yes
     (set-frame-parameter (selected-frame) 'alpha '(90 85))
     (add-to-list 'default-frame-alist '(alpha 90 85))
   #+END_SRC

   #+RESULTS: emacs-transparency

** URL Handling using system
   #+NAME: emacs-url-handling
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq browse-url-browser-function 'browse-url-xdg-open)
   #+END_SRC

   #+RESULTS: emacs-url-handling
   : browse-url-xdg-open

** Default path
   #+NAME: default-path
   #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path
                 "~/.emacs.d/src")
   #+END_SRC
   
** Customizations File
   #+NAME: emacs-customizations
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq custom-file "~/.emacs.d/customizations.el")
     (load custom-file)
   #+END_SRC
** Zone
   #+NAME: emacs-zone
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'zone)
     ;(zone-when-idle 120)
   #+END_SRC
* Elisp libs
** Dash (List lib)
   #+NAME: emacs-dash
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/dash.el")
     (require 'dash)
     (require 'dash-functional)
     (eval-after-load "dash" '(dash-enable-font-lock))
   #+END_SRC
** S (String lib)
   String library
   #+NAME: emacs-s
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/s.el")
     (require 's)
   #+END_SRC
** Ht (Hashtable lib)
   #+NAME: emacs-ht
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/ht.el")
     (require 'ht)
   #+END_SRC
** Loop
   #+NAME: emacs-loop
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/loop.el")
     (require 'loop)
   #+END_SRC
** Tco (Tail call optimization)
   #+NAME: emacs-tco
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/tco.el")
     (require 'tco)
   #+END_SRC
** Names
   Required by Aggressive Indent
   #+NAME: names
   #+BEGIN_SRC emacs-lisp :tangle yes
   (add-to-list 'load-path "~/.emacs.d/src/names")
   #+END_SRC
* Font
  #+NAME: emacs-font
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq preferred-fonts
          '(("Monaco" . 10)
            ("Consolas" . 9)
            ("Source Code Pro" . 10)
            ("Anonymous Pro" . 11)
            ("Inconsolata" . 11)
            ("Bitstream Vera Sans Mono" . 10)
            ("DejaVu Sans Mono" . 10)
            ("Droid Sans Mono" . 10)
            ("Terminus" . 10)
            ))

    (let* ((f (car (-intersection (-map 'car preferred-fonts) (font-family-list))))
           (f (if f
                  (concat f "-" (number-to-string (cdr (assoc f preferred-fonts))))
                nil)))
      (if f
          (progn
            (add-to-list 'default-frame-alist (cons 'font f))
            (set-face-attribute 'default t :font f)
            (set-face-attribute 'default nil :font f)
            (set-frame-font f nil t)
            f)
        nil))
  #+END_SRC

  #+RESULTS: emacs-font
  : Monaco-10

* Autocompletion/Expansion
** Yasnippet
   #+NAME: yasnippet
   #+BEGIN_SRC emacs-lisp :tangle yes  
     (add-to-list 'load-path
                  "~/.emacs.d/src/yasnippet")
     (require 'yasnippet)
     (setq yas-snippet-dirs '("~/.emacs.d/snippets"
                              "~/.emacs.d/src/yasnippet/yasmate/snippets"
                              "~/.emacs.d/src/yasnippet/snippets"
                              ))

     (defun yas/org-very-safe-expand ()
       (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

     (add-hook 'org-mode-hook
               (lambda ()
                 (make-variable-buffer-local 'yas/trigger-key)
                 (setq yas/trigger-key [tab])
                 (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
                 (define-key yas/keymap [tab] 'yas/next-field)))

     (yas-global-mode 1)
   #+END_SRC

   #+RESULTS: yasnippet
   : t
    
** Predictive
   #+NAME: emacs-predictive
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; (add-to-list 'load-path "~/.emacs.d/src/predictive")
     ;; (require 'predictive)
   #+END_SRC

** Company
   #+NAME: emacs-company
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/company-mode")
     (require 'company)
     (setf company-idle-delay 0
           company-minimum-prefix-length 2
           company-show-numbers t
           company-selection-wrap-around t
           company-dabbrev-ignore-case t
           company-dabbrev-ignore-invisible t
           company-dabbrev-downcase nil)
   #+END_SRC

   #+RESULTS: emacs-company
   : company
   
*** Yasnippet Integration
    #+NAME: emacs-company-yasnippet
    #+BEGIN_SRC emacs-lisp :tangle yes
      (when (and (featurep 'yasnippet) (featurep 'company))

        (define-key company-active-map "\t" 'company-yasnippet-or-completion)

        (defun company-yasnippet-or-completion ()
          (interactive)
          (if (yas/expansion-at-point)
              (progn (company-abort)
                     (yas/expand))
            (company-complete-common)))

        (defun yas/expansion-at-point ()
          "Tested with v0.6.1. Extracted from `yas/expand-1'"
          (first (yas/current-key))))
    #+END_SRC
*** Predictive Integration
    #+NAME: emacs-company-predictive
    #+BEGIN_SRC emacs-lisp :tangle yes
      (when (and (featurep 'predictive) (featurep 'company))
        (defun company-predictive (command &optional arg &rest ignored)
          (case command
            (prefix (let* ((text (downcase (word-at-point))))
                      (set-text-properties 0 (length text) nil text)
                      text))
            (candidates (predictive-complete arg))))
        (load "dict-english")
        (add-to-list 'company-backends '(company-predictive)))
    #+END_SRC

    #+RESULTS: emacs-company-predictive
    | (company-predictive) | company-bbdb | company-nxml | company-css | company-eclim | company-semantic | company-clang | company-xcode | company-ropemacs | company-cmake | company-capf | (company-dabbrev-code company-gtags company-etags company-keywords) | company-oddmuse | company-files | company-dabbrev |

** Icicles
   #+NAME: emacs-icicles
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/icicles")
     (require 'icicles)
     (icy-mode 1)
   #+END_SRC

   #+RESULTS: emacs-icicles
   : t
* Parentheses
** Highlight
  #+NAME: emacs-parentheses
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/highlight-parentheses")
    (show-paren-mode t)
    (require 'highlight-parentheses)
  #+END_SRC
** Smartparens
   #+NAME: emacs-smartparens
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/smartparens")
     (require 'smartparens-config)
     (require 'smartparens-latex)
     (require 'smartparens-haskell)
     (require 'smartparens-html)
     (smartparens-global-mode 1)
     (add-hook 'emacs-lisp-mode-hook
               (lambda ()
                 (turn-on-eldoc-mode)))
   #+END_SRC

   #+RESULTS: emacs-smartparens
   | lambda | nil | (turn-on-eldoc-mode) |
** Cedit
   #+NAME: emacs-cedit
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/cedit")
     (require 'cedit)
     (global-set-key (kbd "M-]") 'cedit-slurp)
     (global-set-key (kbd "M-}") 'cedit-barf)
     (global-set-key (kbd "C-:") 'cedit-beginning-of-statement)
     (global-set-key (kbd "C-'") 'cedit-end-of-statement)
     (global-set-key (kbd "C-:") 'cedit-down-block)
     (global-set-key (kbd "C-M-,") 'cedit-up-block-backward)
     (global-set-key (kbd "C-M-.") 'cedit-up-block-forward)
   #+END_SRC
** Paredit
   #+NAME: emacs-paredit
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; (add-to-list 'load-path "~/.emacs.d/src/paredit")
     ;; (require 'paredit)
     ;; (add-hook 'emacs-lisp-mode-hook
     ;;           (lambda ()
     ;;             (paredit-mode t)
     ;;             (turn-on-eldoc-mode)
     ;;             (eldoc-add-command
     ;;              'paredit-backward-delete
     ;;              'paredit-close-round)
     ;;             (local-set-key (kbd "RET") 'electrify-return-if-match)
     ;;             (eldoc-add-command 'electrify-return-if-match)
     ;;             (show-paren-mode t)))
     ;; (global-set-key (kbd "M-[") 'paredit-backward-slurp-sexp)
     ;; (global-set-key (kbd "M-{") 'paredit-backward-barf-sexp)

   #+END_SRC

   #+RESULTS: emacs-paredit
   : paredit-backward-barf-sexp

** Paren-Face
   #+NAME: emacs-paren-face
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/paren-face")
     (require 'paren-face)
     (global-paren-face-mode t)
   #+END_SRC

** Rainbow-blocks
   #+NAME: elisp-raindbow-blocks
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/rainbow-blocks")
     (require 'rainbow-blocks)
   #+END_SRC

   #+RESULTS: elisp-raindbow-blocks
   : rainbow-blocks

** Highlight-stages
   #+NAME: emacs-highlight-stages
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/highlight-stages")
     (require 'highlight-stages)
     (highlight-stages-global-mode 1)
   #+END_SRC

   #+RESULTS: emacs-highlight-stages
   : t

* Highlight Indentation
  #+NAME: emacs-highlight-indentation
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/highlight-indentation")
    (require 'highlight-indentation)
  #+END_SRC

  #+RESULTS: emacs-highlight-indentation
  : highlight-indentation

* Origami
  #+NAME: emacs-origami
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/origami")
    (require 'origami)
    (global-origami-mode 1)
  #+END_SRC

  #+RESULTS: emacs-origami
  : t

* Orgmode
** Basics
   #+NAME: orgmode-basics
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
     (setq org-directory "~/org")
     (global-set-key "\C-cl" 'org-store-link)
     (global-set-key "\C-cc" 'org-capture)
     (global-set-key "\C-ca" 'org-agenda)
     (global-set-key "\C-cb" 'org-iswitchb)
     ;(setq org-startup-indented t) ; bugs in overlay
     (setq org-default-notes-file (concat org-directory "/notes.org"))
     (define-key global-map "\C-cc" 'org-capture)
   #+END_SRC

   #+RESULTS: orgmode-basics
   : browse-url-xdg-open

** Exports
   #+NAME: 
   #+BEGIN_SRC emacs-lisp :tangle yes
     ; your elisp code here
   #+END_SRC

** Captures
   #+NAME: org-capture
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'org-capture-after-finalize-hook
               (lambda () (if (< 1 (length (frames-on-display-list)))
                              (delete-frame))))
     (setq org-capture-templates
           '(
             ("t" "Todo" entry (file+headline "captures.org" "Tasks")
              "* TODO %?\n  %U\n  %i\n  %a")
             ("w" "conkeror-integration" entry (file+headline "captures.org" "Web")
              "* %?\n  Source: %u, %c\n\n  %i\n")
             ("b" "Buy" checkitem (file+headline "captures.org" "Buy"))
             ("j" "Journal" entry (file+datetree "journal.org")
              "* %?\n  Entered on %U\n  %i\n  %a")
             ))
   #+END_SRC

   #+RESULTS: org-capture
   | t | Todo                 | entry     | (file+headline captures.org Tasks) | * TODO %?\n  %U\n  %i\n  %a       |
   | w | conkeror-integration | entry     | (file+headline captures.org Web)   | * %?\n  Source: %u, %c\n\n  %i\n  |
   | b | Buy                  | checkitem | (file+headline captures.org Buy)   |                                   |
   | j | Journal              | entry     | (file+datetree journal.org)        | * %?\n  Entered on %U\n  %i\n  %a |

** Babel
   #+NAME: orgmode-babel
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;(org-confirm-babel-evaluate nil)
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((R . t)
        (emacs-lisp . t)
        (plantuml . t)
        (latex . t)
        (dot . t)
        ))
     (setq org-plantuml-jar-path
           (expand-file-name "~/.emacs.d/plantuml.jar"))
     (setq org-confirm-babel-evaluate nil)
     (setq org-src-fontify-natively t)
     (setq org-export-htmlize-output-type 'inline-css)
   #+END_SRC

   #+RESULTS: orgmode-babel
   : inline-css

** Org-Impress-js
   #+NAME: org-impress.js
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/org-impress-js")
     (require 'ox-impress-js)
   #+END_SRC

   #+RESULTS: org-impress.js
   : org-impress-js
** Ob-Metapost
   #+NAME: emacs-ob-metapost
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'ob-metapost)
   #+END_SRC
   
** Org-Eldoc
   #+NAME: org-eldoc
   #+BEGIN_SRC emacs-lisp :tangle yes
     ; (add-to-list 'load-path "~/.emacs.d/src/org-eldoc")
     ;(require 'org-eldoc)
     ;(org-eldoc-hook-setup)
   #+END_SRC
   
** Remember
   #+NAME: emacs-org-remember
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/remember-el")
     (require 'remember)
     (setq remember-annotation-functions '(org-remember-annotation))
     (setq remember-handler-functions '(org-remember-handler))
     (add-hook 'remember-mode-hook 'org-remember-apply-template)
   #+END_SRC
** TaskJuggler
   #+NAME: emacs-taskjuggler
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'ox-taskjuggler)
   #+END_SRC
** O-Blog
   #+NAME: emacs-o-blog
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path "~/.emacs.d/src/o-blog/lisp")
     (require 'o-blog)
   #+END_SRC

   #+RESULTS: emacs-o-blog
   : o-blog

** Ob-PlantUML ImageMagick Support
   #+NAME: emacs-ob-plantuml-imagemagick
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'ob-plantuml)
     (require 'ob-latex) ; for convert shell-out
     (require 'advice)

     (defadvice org-babel-execute:plantuml (after org-babel-execute:plantuml:imagemagick)
       (let* ((params (ad-get-arg 1))
              (out-file (cdr (assoc :file params)))
              (imagemagick (cdr (assoc :imagemagick params)))
              (im-in-options (cdr (assoc :iminoptions params)))
              (im-out-options (cdr (assoc :imoutoptions params))))
         (cond (imagemagick
                (org-babel-latex-convert-pdf out-file out-file im-in-options im-out-options)))))

     (ad-enable-advice 'org-babel-execute:plantuml 'after 'org-babel-execute:plantuml:imagemagick)
     (ad-activate 'org-babel-execute:plantuml)
   #+END_SRC

   #+RESULTS: emacs-ob-plantuml-imagemagick
   : org-babel-execute:plantuml

** Graphviz ImageMagick and Notugly Xslt Integration
   #+NAME: emacs-graphviz-notugly
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'ob-dot)
     (require 'ob-latex) ; for convert shell-out
     (require 'advice)

     (defadvice org-babel-execute:dot (around org-babel-execute:dot:notugly)
       (let* ((params (ad-get-arg 1))
              (out-file (cdr (assoc :file params)))
              (out-file-svg (concat (file-name-sans-extension out-file) ".svg"))
              (imagemagick (cdr (assoc :imagemagick params)))
              (im-in-options (cdr (assoc :iminoptions params)))
              (im-out-options (cdr (assoc :imoutoptions params))))
         (if imagemagick
             (progn
               (with-temp-buffer
                 (ad-set-arg 1 (cons (cons :file out-file-svg)
                                     (assq-delete-all :file (copy-alist params))))
                 ad-do-it
                 (let* ((cmd (concat
                              "xsltproc ~/.emacs.d/src/diagram-tools/notugly.xsl "
                              out-file-svg)))
                   (message "Shell command: %s" cmd)
                   (insert (shell-command-to-string cmd)))
                 (write-file out-file-svg))
               (org-babel-latex-convert-pdf out-file-svg out-file im-in-options im-out-options)
               (when (file-exists-p out-file-svg)
                 (delete-file out-file-svg)))
           ad-do-it)))

     (ad-enable-advice 'org-babel-execute:dot 'around 'org-babel-execute:dot:notugly)
     (ad-activate 'org-babel-execute:dot)
   #+END_SRC

   #+RESULTS: emacs-graphviz-notugly
   : org-babel-execute:dot

** Font Size
   #+NAME: emacs-orgmode-font-size
   #+BEGIN_SRC emacs-lisp :tangle yes
     (custom-set-faces
      '(org-level-1 ((t (:inherit outline-1 :height 1.0))))
      '(org-level-2 ((t (:inherit outline-2 :height 1.0))))
      '(org-level-3 ((t (:inherit outline-3 :height 1.0))))
      '(org-level-4 ((t (:inherit outline-4 :height 1.0))))
      '(org-level-5 ((t (:inherit outline-5 :height 1.0))))
      )
   #+END_SRC
* Smart Mode Line
  #+NAME: emacs-smart-modeline
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/rich-minority")
    (add-to-list 'load-path "~/.emacs.d/src/smart-mode-line")
    (require 'rich-minority)
    (require 'smart-mode-line)
    (sml/setup)
    (sml/apply-theme 'dark)
    (rich-minority-mode 1)    
  #+END_SRC
* Theme
** Monokai
  #+NAME: emacs-monokai
  #+BEGIN_SRC emacs-lisp :tangle yes
    ;; (defun setup-window-system-frame-colours (&rest frame)
    ;;   (if window-system
    ;;       (let ((f (if (car frame)
    ;;                    (car frame)
    ;;                  (selected-frame))))
    ;;         (progn
    ;;           (set-frame-font "Bera Sans Mono-11")
    ;;           (set-face-background 'default "#232F2F" f)
    ;;           (set-face-foreground 'default "#FFFFFF" f)
    ;;           (set-face-background 'fringe  "#000000" f)
    ;;           (set-face-background 'cursor "#2F4F4F" f)
    ;;           (set-face-background 'mode-line "#2F4F4F" f)
    ;;           (set-face-foreground 'mode-line "#BCBf91" f)))))

    ;; (require 'server)
    ;; (defadvice server-create-window-system-frame
    ;;   (after set-window-system-frame-colours ())
    ;;   "Set custom frame colours when creating the first frame on a display"
    ;;   (message "Running after frame-initialize")
    ;;   (setup-window-system-frame-colours))
    ;; (ad-activate 'server-create-window-system-frame)
    ;; (add-hook 'after-make-frame-functions 'setup-window-system-frame-colours t)

    (add-to-list 'custom-theme-load-path "~/.emacs.d/src/monokai-emacs")
    (load-theme 'monokai t)
  #+END_SRC

  #+RESULTS: emacs-monokai
  : t

  #+RESULTS: emacs-theme
  : t
* Popwin
  #+NAME: emacs-popwin
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/popwin")
    (require 'popwin)
    ;; (popwin-mode 1)
  #+END_SRC

  #+RESULTS: emacs-popwin
  : t

* Guide Key
  #+NAME: emacs-guide-key
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/guide-key")
    (require 'guide-key)
    (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
    (guide-key-mode 1)
  #+END_SRC

  #+RESULTS: emacs-guide-key
  : t

* Golden Ratio
  #+NAME: emacs-golden-ratio
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/golden-ratio")
    (require 'golden-ratio)
    (setq golden-ratio-exclude-modes '("ediff-mode"
                                       "eshell-mode"
                                       "dired-mode"
                                       "calendar-mode"
                                       ))
    (setq golden-ratio-exclude-buffer-names '(" *Org tags*"
                                              " *Org todo*"
                                              " *Org adenda*"
                                              "*phi-search*"
                                              ))
    (golden-ratio-mode 1)
  #+END_SRC

  #+RESULTS: emacs-golden-ratio
  : t

* Tiling
  #+NAME: emacs-tiling
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'buffer-move)
    (require 'tiling)

    ;;; Windows related operations
    ;; Split & Resize
    (define-key global-map (kbd "C-x |") 'split-window-horizontally)
    (define-key global-map (kbd "C-x _") 'split-window-vertically)
    ;; (define-key global-map (kbd "C-{") 'shrink-window-horizontally)
    ;; (define-key global-map (kbd "C-}") 'enlarge-window-horizontally)
    ;; (define-key global-map (kbd "C-^") 'enlarge-window)
    ;; Navgating: Windmove uses C-<up> etc.
    (define-key global-map (kbd "C-<up>"   )  'windmove-up)
    (define-key global-map (kbd "C-<down>" )  'windmove-down)
    (define-key global-map (kbd "C-<right>" ) 'windmove-right)
    (define-key global-map (kbd "C-<left>")   'windmove-left)
    ;; Swap buffers: M-<up> etc.
    (define-key global-map (kbd "M-<up>"   ) 'buf-move-up)
    (define-key global-map (kbd "M-<down>" ) 'buf-move-down)
    (define-key global-map (kbd "M-<right>") 'buf-move-right)
    (define-key global-map (kbd "M-<left>" ) 'buf-move-left)
    ;; Tile
    (define-key global-map (kbd "C-\\") 'tiling-cycle) ; accepts prefix number
    (define-key global-map (kbd "C-M-<up>") 'tiling-tile-up)
    (define-key global-map (kbd "C-M-<down>") 'tiling-tile-down)
    (define-key global-map (kbd "C-M-<right>") 'tiling-tile-right)
    (define-key global-map (kbd "C-M-<left>") 'tiling-tile-left)
    ;; Another type of representation of same keys, in case your terminal doesn't
    ;; recognize above key-binding. Tip: C-h k C-up etc. to see into what your
    ;; terminal tranlated the key sequence.
    ;; (define-key global-map (kbd "M-[ a"     ) 'windmove-up)
    ;; (define-key global-map (kbd "M-[ b"     ) 'windmove-down)
    ;; (define-key global-map (kbd "M-[ c"     ) 'windmove-right)
    ;; (define-key global-map (kbd "M-[ d"     ) 'windmove-left)
    ;; (define-key global-map (kbd "ESC <up>"   ) 'buf-move-up)
    ;; (define-key global-map (kbd "ESC <down>" ) 'buf-move-down)
    ;; (define-key global-map (kbd "ESC <right>") 'buf-move-right)
    ;; (define-key global-map (kbd "ESC <left>" ) 'buf-move-left)
    ;; (define-key global-map (kbd "ESC M-[ a" ) 'tiling-tile-up)
    ;; (define-key global-map (kbd "ESC M-[ b" ) 'tiling-tile-down)
    ;; (define-key global-map (kbd "ESC M-[ c" ) 'tiling-tile-right)
    ;; (define-key global-map (kbd "ESC M-[ d" ) 'tiling-tile-left)
  #+END_SRC
* Comments
  #+NAME: emacs-hide-comnt
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'hide-comnt)
  #+END_SRC
  
* Columnize
  select and M-x columnize-strings <ret>

  #+NAME: emacs-columnize
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'columnize)
  #+END_SRC
* Graphviz
  #+NAME: emacs-graphviz
  #+BEGIN_SRC emacs-lisp :tangle yes
    (load-file "~/.emacs.d/src/graphviz-dot-mode.el")
  #+END_SRC
  
* PlantUML
   #+NAME: default-path
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; (when (file-exists-p "~/.emacs.d/plantuml.jar")
     ;;   (require 'plantuml-mode))
   #+END_SRC
  
* Calfw
  Calendars in ~/calendar should be updated with cron.
  #+NAME: calendar
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path
                 "~/.emacs.d/src/emacs-calfw")
    (require 'calfw)
    ;(require 'calfw-cal)
    (require 'calfw-ical)
    (require 'calfw-org)

    (defun my-open-calendar ()
      (interactive)
      (cfw:open-calendar-buffer
       :contents-sources
       (list
        ;(cfw:org-create-source "Green")  ; orgmode source
        ;(cfw:cal-create-source "Orange") ; diary source
        (cfw:ical-create-source "main"  "~/calendars/my-main.ics" "IndianRed")
        (cfw:ical-create-source "bdays" "~/calendars/my-birthdays.ics" "Orange")
        (cfw:org-create-source "Green")
       )))

  #+END_SRC

  #+RESULTS: calendar
  : my-open-calendar

* mu4e
  #+NAME: emacs-mu4e
  #+BEGIN_SRC emacs-lisp :tangle yes
    (if (file-exists-p "~/.mu4e.el")
        (load-file "~/.mu4e.el"))
  #+END_SRC

  #+RESULTS: emacs-mu4e
  : t

* Expand Region
  #+NAME: expand-region
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path
                 "~/.emacs.d/src/expand-region.el")
    (require 'expand-region)
    (global-set-key (kbd "M-=") 'er/expand-region)
  #+END_SRC

  #+RESULTS: expand-region
  : er/expand-region
  
* Region Bindings
  #+NAME: emacs-region-bindings
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/region-bindings-mode")
    (require 'region-bindings-mode)
    (region-bindings-mode-enable)
    (define-key region-bindings-mode-map (kbd "M--") 'mc/mark-all-like-this)
    (define-key region-bindings-mode-map (kbd "M-[") 'mc/mark-previous-like-this)
    (define-key region-bindings-mode-map (kbd "M-]") 'mc/mark-next-like-this)
  #+END_SRC

  #+RESULTS: emacs-region-bindings
  : mc/mark-next-like-this

* Multiple Cursors
  #+NAME: emacs-mult-cursor
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path
                 "~/.emacs.d/src/multiple-cursors.el")
    (require 'multiple-cursors)
    (global-set-key (kbd "C-c m /") 'mc/edit-lines)
    (global-set-key (kbd "C-c m .") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-c m ,") 'mc/mark-previous-like-this)
    (global-set-key (kbd "C-c m m") 'mc/mark-all-like-this)
  #+END_SRC

  #+RESULTS: emacs-mult-cursor
  : mc/mark-all-like-this

* Phi-search
  Incremental Search that works with Multiple Cursors.
  #+NAME: emacs-phi-search
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path
                 "~/.emacs.d/src/phi-search")
    (require 'phi-search)
    (require 'phi-replace)
    (global-set-key (kbd "C-s") 'phi-search)
    (global-set-key (kbd "C-r") 'phi-search-backward)
    (global-set-key (kbd "M-%") 'phi-replace-query)
  #+END_SRC

  #+RESULTS: emacs-phi-search
  : phi-replace-query

* Smart Movement
  Requires expand-region
  #+NAME: emacs-smart-forward
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/smart-forward")
    (require 'smart-forward)
    ;(global-set-key (kbd "M-<up>") 'smart-up)
    ;(global-set-key (kbd "M-<down>") 'smart-down)
    ;(global-set-key (kbd "M-<left>") 'smart-backward)
    ;(global-set-key (kbd "M-<right>") 'smart-forward)
  #+END_SRC
  
* Change Inner
  Requires expand-region
  #+NAME: emacs-change-inner
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/change-inner.el")
    (require 'change-inner)
    (global-set-key (kbd "M-i") 'change-inner)
    (global-set-key (kbd "M-o") 'change-outer)
  #+END_SRC
  
* Wrap Selection
  #+NAME: emacs-wrap-region
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/wrap-region")
    (require 'wrap-region)
    (wrap-region-mode t)
    ;(add-to-list 'wrap-region-except-modes 'conflicting-mode)
  #+END_SRC
  
* Cucumber
  #+NAME: emacs-cucumber
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/cucumber.el")
    (require 'feature-mode)
  #+END_SRC
  
* Fish
  #+NAME: emacs-fish
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/emacs-fish")
    (require 'fish-mode)
    (add-to-list 'auto-mode-alist '("\\.fish\\'" . fish-mode))
    (add-to-list 'interpreter-mode-alist '("fish" . fish-mode))
  #+END_SRC

  #+RESULTS: emacs-fish
  : fish-mode
  
* Yaml
  #+NAME: emacs-yaml
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/yaml-mode")
    (require 'yaml-mode)
    (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
    (add-to-list 'auto-mode-alist '("\\.yaml$" . yaml-mode))
  #+END_SRC

* XML
** Emmet
   #+NAME: emacs-emmet
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'load-path
                  "~/.emacs.d/src/emmet-mode")
     (require 'emmet-mode)
     (add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes
     (add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.
     ;; (add-hook 'emmet-mode-hook (lambda () (setq emmet-indent-after-insert nil)))
     ;; (add-hook 'emmet-mode-hook (lambda () (setq emmet-indentation 2))) ;; indent 2 spaces.
     ;; (setq emmet-move-cursor-between-quotes t) ;; default nil
     ;; (setq emmet-move-cursor-after-expanding nil) ;; default t
   #+END_SRC

   #+RESULTS: xpath2xml
   | zencoding-mode |
   
* Haskell
  #+NAME: haskell
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/haskell-mode")
    (require 'haskell-mode-autoloads)
  #+END_SRC

  #+RESULTS: haskell
  | turn-on-haskell-indentation | turn-on-haskell-doc-mode |
  
* Perl
  #+NAME: perl
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defalias 'perl-mode 'cperl-mode)
    (require 'perltidy)
    (require 'flymake)
    (require 'perl-completion)
    (eval-after-load 'perl-mode
      '(define-key perl-mode-map (kbd "C-c p") 'perltidy-dwim))
    (add-hook 'perl-mode-hook
              (lambda ()
                ;; (flymake-mode t)
                ;; (perl-completion-mode t)
                (turn-on-eldoc-mode)
                ))
  #+END_SRC

  #+RESULTS: perl
  | lambda | nil | (flymake-mode t) | (perl-completion-mode t) |
  | lambda | nil | (flymake-mode 1) |                          |
* OCaml
** Tuareg
   #+NAME: emacs-tuareg
   #+BEGIN_SRC emacs-lisp :tangle yes
     (load "~/.emacs.d/src/tuareg/tuareg-site-file.el")
     (add-to-list 'auto-mode-alist '("\\.eliom$" . tuareg-mode))
   #+END_SRC

** Opam
   #+NAME: emacs-opam
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (executable-find "opam")
       (setq opam-share (substring (shell-command-to-string
                                    "opam config var share 2> /dev/null") 0 -1))
       (add-to-list 'load-path (concat opam-share "/emacs/site-lisp"))
       (provide 'opam-executable-integration))
   #+END_SRC
   
** Merlin
   #+NAME: emacs-merlin
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (featurep 'opam-executable-integration)
       (require 'merlin)
       (add-hook 'tuareg-mode-hook 'merlin-mode)
       (add-hook 'caml-mode-hook 'merlin-mode)
       (setq merlin-command 'opam))
   #+END_SRC

*** Company Integration
    #+NAME: emacs-merlin-company
    #+BEGIN_SRC emacs-lisp :tangle yes
      (when (and (featurep 'merlin) (featurep 'company))
        (add-to-list 'company-backends 'merlin-company-backend)
        (add-hook 'merlin-mode-hook 'company-mode))
    #+END_SRC
    
* Racket
  Order important
** Geiser
   #+NAME: emacs-geiser
   #+BEGIN_SRC emacs-lisp :tangle yes
     (load-file "~/.emacs.d/src/geiser/elisp/geiser.el")
     (add-hook 'geiser-mode-hook
               (lambda ()
                 (paredit-mode t)
                 (local-set-key (kbd "RET") 'electrify-return-if-match)
                 (show-paren-mode t)))
   #+END_SRC
** Quack
   #+NAME: emacs-quack
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (executable-find "racket")
       (require 'quack))
   #+END_SRC
* Rust
  #+NAME: emacs-rust
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/rust-mode")
    (require 'rust-mode)
    (add-to-list 'auto-mode-alist '("\\.rs$" . rust-mode))
  #+END_SRC

  #+RESULTS: emacs-rust

* Coq
  #+NAME: emacs-coq
  #+BEGIN_SRC emacs-lisp :tangle yes
    (when (executable-find "coqtop")
      (load-file "~/.emacs.d/src/ProofGeneral/generic/proof-site.el")
      (eval-after-load 'coq
        '(setq coq-prog-args
               `("-emacs-U"
                 "-R"
                 ,(expand-file-name
                   "~/.emacs.d/src/cpdt/src")
                 "Cpdt"))))
  #+END_SRC

  #+RESULTS: emacs-coq
  | -emacs-U | -R | ~/.emacs.d/src/cpdt/src | Cpdt |

* Magit
  #+NAME: emacs-magit
  #+BEGIN_SRC emacs-lisp :tangle yes
    (when (executable-find "git")
      (add-to-list 'load-path "~/.emacs.d/src/git-modes")
      (add-to-list 'load-path "~/.emacs.d/src/magit")
      (eval-after-load 'info
        '(progn (info-initialize)
                (add-to-list 'Info-directory-list "~/.emacs.d/src/magit")))
      (require 'magit))
  #+END_SRC
  
* String Edit
  #+NAME: emacs-string-edit
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/string-edit.el")
    (require 'string-edit)
    ;string-edit-at-point
  #+END_SRC
  
* Flycheck
  not working atm.
  #+NAME: emacs-flycheck
  #+BEGIN_SRC emacs-lisp :tangle yes
    ;(add-to-list 'load-path "~/.emacs.d/src/flycheck")
    ;(require 'flycheck)
    ;(add-hook 'after-init-hook #'global-flycheck-mode)
  #+END_SRC
  
* Ledger
  #+NAME: emacs-ledger
  #+BEGIN_SRC emacs-lisp :tangle yes
    (when (executable-find "ledger")
      (add-to-list 'load-path "~/.emacs.d/src/ledger")
      (require 'ledger-mode)
      (add-to-list 'auto-mode-alist '("\\.ledger$" . ledger-mode)))
  #+END_SRC
* AUCTeX
  #+NAME: auctex
  #+BEGIN_SRC emacs-lisp :tangle yes
    (when (executable-find "pdflatex")
      (load "~/.emacs.d/src/auctex.el" nil t t)
      (load "~/.emacs.d/src/preview-latex.el" nil t t)
      (setq TeX-auto-save t)
      (setq TeX-parse-self t)
      (setq-default TeX-master nil)
      (add-hook 'LaTeX-mode-hook 'visual-line-mode)
      (add-hook 'LaTeX-mode-hook 'flyspell-mode)
      (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
      (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
      (setq reftex-plug-into-AUCTeX t)
      (setq TeX-PDF-mode t))
  #+END_SRC

  #+RESULTS: auctex
  : t

* Crontab
  #+NAME: emacs-crontab-mode
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'crontab-mode)
    (add-to-list 'auto-mode-alist '("\\.cron\\(tab\\)?\\'" . crontab-mode))
    (add-to-list 'auto-mode-alist '("cron\\(tab\\)?\\."    . crontab-mode))
  #+END_SRC

  #+RESULTS: emacs-crontab-mode

* UndoTree
  #+NAME: emacs-undotree
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/undo-tree")
    (require 'undo-tree)
    (global-undo-tree-mode 1)
    (global-set-key (kbd "C-z") 'undo)
    (global-set-key (kbd "C-M-z") 'redo)
  #+END_SRC

  #+RESULTS: emacs-undotree
  : t

* Aggressive Indent
  #+NAME: emacs-aggressive-indent
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/aggressive-indent-mode")
    (require 'aggressive-indent)
    ;(global-aggressive-indent-mode nil)
    (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
  #+END_SRC

  #+RESULTS: emacs-aggressive-indent
  | html-mode | bibtex-mode | cider-repl-mode | coffee-mode | conf-mode | Custom-mode | diff-mode | dos-mode | erc-mode | jabber-chat-mode | haml-mode | haskell-mode | makefile-mode | makefile-gmake-mode | minibuffer-inactive-mode | netcmd-mode | python-mode | sass-mode | slim-mode | special-mode | shell-mode | snippet-mode | eshell-mode | tabulated-list-mode | term-mode | TeX-output-mode | text-mode | yaml-mode |

* Markdown
  #+NAME: emacs-markdown
  #+BEGIN_SRC emacs-lisp :tangle yes
    (autoload 'markdown-mode "markdown-mode"
      "Major mode for editing Markdown files" t)
    (add-to-list 'auto-mode-alist '("\\.text\\'" . markdown-mode))
    (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
    (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
  #+END_SRC
* Relative Line Numbers
  #+NAME: emacs-relinum
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/linum-relative")
    (require 'linum-relative)
    (linum-relative-toggle) ;; turn off by default

    (defun call-macro-linum (arg)
      "blablah"
      (interactive "nTimes: ")
      (kmacro-end-and-call-macro arg))

    (defmacro with-linum-relative (&rest body)
      (let ((linum-format-current (make-symbol "linum-format-current")))
        `(let ((,linum-format-current linum-format))
           (setq linum-format 'linum-relative)
           (linum-update (current-buffer))
           (unwind-protect (progn ,@body)
             (setq linum-format ,linum-format-current)))))

    (defun call-macro-linum-wrap ()
      (interactive)
      (with-linum-relative
       (call-interactively 'call-macro-linum)))

    (global-set-key (kbd "C-x E")
                    'call-macro-linum-wrap)       
  #+END_SRC

  #+RESULTS: emacs-relinum
  : call-macro-linum-wrap

* Key Chord
  #+NAME: emacs-key-Chord
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'key-chord)
    (key-chord-mode 1)
  #+END_SRC

  #+RESULTS: emacs-key-Chord
  : Key Chord mode on

* Hydra
  #+NAME: emacs-hydra
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/hydra")
    (require 'hydra)
  #+END_SRC

  #+RESULTS: emacs-hydra
  : hydra

** Scale Text
   #+NAME: emacs-scale-text
   #+BEGIN_SRC emacs-lisp :tangle yes
     (key-chord-define-global
      "-="
      (defhydra hydra-zoom ()
        "zoom"
        ("=" text-scale-increase "in")
        ("-" text-scale-decrease "out")))
   #+END_SRC

   #+RESULTS: emacs-scale-text
   : hydra-zoom/body

** Move Text
   #+NAME: emacs-hydra-move-text
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'move-text)
     (key-chord-define-global
      "ws"
      (defhydra hydra-move-text ()
        "Move text"
        ("w" move-text-up "up")
        ("s" move-text-down "down")))
   #+END_SRC

   #+RESULTS: emacs-hydra-move-text
   : hydra-move-text/body

** Org clock
   #+NAME: emacs-org-clock
   #+BEGIN_SRC emacs-lisp :tangle yes
     (key-chord-define-global
      "wc"
      (defhydra hydra-org-clock (:color blue :hint nil)
        "
     Clock   In/out^     ^Edit^   ^Summary     (_?_)
     -----------------------------------------
             _i_n         _e_dit   _g_oto entry
             _c_ontinue   _q_uit   _d_isplay
             _o_ut        ^ ^      _r_eport
           "
        ("i" org-clock-in)
        ("o" org-clock-out)
        ("c" org-clock-in-last)
        ("e" org-clock-modify-effort-estimate)
        ("q" org-clock-cancel)
        ("g" org-clock-goto)
        ("d" org-clock-display)
        ("r" org-clock-report)
        ("?" (org-info "Clocking commands"))))
   #+END_SRC

   #+RESULTS: emacs-org-clock
   : hydra-org-clock/body

** Smartparens
   #+NAME: emacs-hydra-smartparens
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (featurep 'smartparens)
       (key-chord-define-global
        "90"
        (defhydra hydra-learn-sp (:hint nil)
          "
       _B_ backward-sexp            -----
       _F_ forward-sexp               _s_ splice-sexp
       _L_ backward-down-sexp         _df_ splice-sexp-killing-forward
       _H_ backward-up-sexp           _db_ splice-sexp-killing-backward
     ^^------                         _da_ splice-sexp-killing-around
       _k_ down-sexp                -----
       _j_ up-sexp                    _C-s_ select-next-thing-exchange
     -^^-----                         _C-p_ select-previous-thing
       _n_ next-sexp                  _C-n_ select-next-thing
       _p_ previous-sexp            -----
       _a_ beginning-of-sexp          _C-f_ forward-symbol
       _z_ end-of-sexp                _C-b_ backward-symbol
     --^^-                          -----
       _t_ transpose-sexp             _c_ convolute-sexp
     -^^--                            _g_ absorb-sexp
       _x_ delete-char                _q_ emit-sexp
       _dw_ kill-word               -----
       _dd_ kill-sexp                 _,b_ extract-before-sexp
     -^^--                            _,a_ extract-after-sexp
       _S_ unwrap-sexp              -----
     -^^--                            _AP_ add-to-previous-sexp
       _C-h_ forward-slurp-sexp       _AN_ add-to-next-sexp
       _C-l_ forward-barf-sexp      -----
       _C-S-h_ backward-slurp-sexp    _ join-sexp
       _C-S-l_ backward-barf-sexp     _|_ split-sexp
     "
          ;; TODO: Use () and [] - + * | <space>
          ("B" sp-backward-sexp );; similiar to VIM b
          ("F" sp-forward-sexp );; similar to VIM f
          ;;
          ("L" sp-backward-down-sexp )
          ("H" sp-backward-up-sexp )
          ;;
          ("k" sp-down-sexp ) ; root - towards the root
          ("j" sp-up-sexp )
          ;;
          ("n" sp-next-sexp )
          ("p" sp-previous-sexp )
          ;; a..z
          ("a" sp-beginning-of-sexp )
          ("z" sp-end-of-sexp )
          ;;
          ("t" sp-transpose-sexp )
          ;;
          ("x" sp-delete-char )
          ("dw" sp-kill-word )
          ;;("ds" sp-kill-symbol ) ;; Prefer kill-sexp
          ("dd" sp-kill-sexp )
          ;;("yy" sp-copy-sexp ) ;; Don't like it. Pref visual selection
          ;;
          ("S" sp-unwrap-sexp ) ;; Strip!
          ;;("wh" sp-backward-unwrap-sexp ) ;; Too similar to above
          ;;
          ("C-h" sp-forward-slurp-sexp )
          ("C-l" sp-forward-barf-sexp )
          ("C-S-h" sp-backward-slurp-sexp )
          ("C-S-l" sp-backward-barf-sexp )
          ;;
          ;;("C-[" (bind (sp-wrap-with-pair "[")) ) ;;FIXME
          ;;("C-(" (bind (sp-wrap-with-pair "(")) )
          ;;
          ("s" sp-splice-sexp )
          ("df" sp-splice-sexp-killing-forward )
          ("db" sp-splice-sexp-killing-backward )
          ("da" sp-splice-sexp-killing-around )
          ;;
          ("C-s" sp-select-next-thing-exchange )
          ("C-p" sp-select-previous-thing )
          ("C-n" sp-select-next-thing )
          ;;
          ("C-f" sp-forward-symbol )
          ("C-b" sp-backward-symbol )
          ;;
          ;;("C-t" sp-prefix-tag-object)
          ;;("H-p" sp-prefix-pair-object)
          ("c" sp-convolute-sexp )
          ("g" sp-absorb-sexp )
          ("q" sp-emit-sexp )
          ;;
          (",b" sp-extract-before-sexp )
          (",a" sp-extract-after-sexp )
          ;;
          ("AP" sp-add-to-previous-sexp );; Difference to slurp?
          ("AN" sp-add-to-next-sexp )
          ;;
          ("_" sp-join-sexp ) ;;Good
          ("|" sp-split-sexp ))))
   #+END_SRC

   #+RESULTS: emacs-hydra-smartparens
   : hydra-learn-sp/body

** Origami
   #+NAME: emacs-hydra-origami
   #+BEGIN_SRC emacs-lisp :tangle yes
     (key-chord-define-global
      ",."
      (defhydra hydra-folding (:color red)
        "
       _o_pen node    _n_ext fold       toggle _f_orward
       _c_lose node   _p_revious fold   toggle _a_ll
       "
        ("o" origami-open-node)
        ("c" origami-close-node)
        ("n" origami-next-fold)
        ("p" origami-previous-fold)
        ("f" origami-forward-toggle-node)
        ("a" origami-toggle-all-nodes)))
   #+END_SRC

   #+RESULTS: emacs-hydra-origami
   : hydra-folding/body

* CMake
  #+NAME: emacs-cmake
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'cmake-mode)
    (add-to-list 'load-path "~/.emacs.d/src/cmake-font-lock")
    (autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)
    (add-hook 'cmake-mode-hook 'cmake-font-lock-activate)
    (add-to-list 'load-path "~/.emacs.d/src/cmake-project")
    (require 'cmake-project)
    (defun maybe-cmake-project-hook ()
      (if (file-exists-p "CMakeLists.txt") (cmake-project-mode)))
    (add-hook 'c-mode-hook 'maybe-cmake-project-hook)
    (add-hook 'c++-mode-hook 'maybe-cmake-project-hook)
  #+END_SRC

  #+RESULTS: emacs-cmake
  | maybe-cmake-project-hook |

* Sublimity
  #+NAME: emacs-sublime
  #+BEGIN_SRC emacs-lisp :tangle yes
    ;(add-to-list 'load-path "~/.emacs.d/src/sublimity")
    ;(require 'sublimity)
    ;; (require 'sublimity-scroll)
    ;; (require 'sublimity-map)
    ;; (require 'sublimity-attractive)
    ;(sublimity-mode 1)
  #+END_SRC

  #+RESULTS: emacs-sublime
  : t

* Phi-grep
  #+NAME: emacs-phi-grep
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/src/phi-grep")
    (require 'phi-grep)
  #+END_SRC

  #+RESULTS: emacs-phi-grep
  : phi-grep

* Definitions
** Eval elips anywhere and replace with result
   #+NAME: eval-and-replace
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun eval-and-replace ()
       "Replace the preceding sexp with its value."
       (interactive)
       (backward-kill-sexp)
       (condition-case nil
           (prin1 (eval (read (current-kill 0)))
                  (current-buffer))
         (error (message "Invalid expression")
                (insert (current-kill 0)))))
     (global-set-key (kbd "C-x C-M-e") 'eval-and-replace)
   #+END_SRC

   #+RESULTS: eval-and-replace
   : eval-and-replace

** Kill file
   #+NAME: kill-file
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun delete-current-buffer-file ()
       "Removes file connected to current buffer and kills buffer."
       (interactive)
       (let ((filename (buffer-file-name))
             (buffer (current-buffer))
             (name (buffer-name)))
         (if (not (and filename (file-exists-p filename)))
             (ido-kill-buffer)
           (when (yes-or-no-p "Are you sure you want to remove this file? ")
             (delete-file filename)
             (kill-buffer buffer)
             (message "File '%s' successfully removed" filename)))))
     (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)
   #+END_SRC

   #+RESULTS: kill-file
   : delete-current-buffer-file

** Rename file
   #+NAME: rename-file
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun rename-current-buffer-file ()
       "Renames current buffer and file it is visiting."
       (interactive)
       (let ((name (buffer-name))
             (filename (buffer-file-name)))
         (if (not (and filename (file-exists-p filename)))
             (error "Buffer '%s' is not visiting a file!" name)
           (let ((new-name (read-file-name "New name: " filename)))
             (if (get-buffer new-name)
                 (error "A buffer named '%s' already exists!" new-name)
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)
               (message "File '%s' successfully renamed to '%s'"
                        name (file-name-nondirectory new-name)))))))
     (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)
   #+END_SRC

   #+RESULTS: rename-file
   : rename-current-buffer-file

** Transpose Lines
   #+NAME: transpose-lines
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun move-line-down ()
       (interactive)
       (let ((col (current-column)))
         (save-excursion
           (forward-line)
           (transpose-lines 1))
         (forward-line)
         (move-to-column col)))
     (defun move-line-up ()
       (interactive)
       (let ((col (current-column)))
         (save-excursion
           (forward-line)
           (transpose-lines -1))
         (move-to-column col)))
     (global-set-key (kbd "<C-S-down>") 'move-line-down)
     (global-set-key (kbd "<C-S-up>") 'move-line-up)
   #+END_SRC

   #+RESULTS: transpose-lines
   : move-line-up
   
** Open Line (above or below)
   #+NAME: open-line
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun open-line-below ()
       (interactive)
       (end-of-line)
       (newline)
       (indent-for-tab-command))
     (defun open-line-above ()
       (interactive)
       (beginning-of-line)
       (newline)
       (forward-line -1)
       (indent-for-tab-command))
     (global-set-key (kbd "<C-return>") 'open-line-below)
     (global-set-key (kbd "<C-S-return>") 'open-line-above)
   #+END_SRC

   #+RESULTS: open-line
   : open-line-above

** TODO Relative Line Numbers
   TODO: make it contextual to C-u or macros

   #+NAME: linum-relative
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; (setq linum-last-pos 0) ; needed during sturtup

     ;; (defadvice linum-update (before linum-relativenumber-linum-update activate)
     ;;   (setq linum-last-pos (line-number-at-pos)))

     ;; (defun linum-relativenumber-format (line-number)
     ;;   (let ((diff (abs (- line-number linum-last-pos)))
     ;;         (w (length (number-to-string
     ;;                     (count-lines (point-min) (point-max))))))
     ;;     (concat (format "%d " line-number)
     ;;             (format (concat "%" (number-to-string
     ;;                                  (+ w (- w (length (number-to-string line-number))))) "d ")
     ;;                     diff))))

     ;; (defun goto-line-with-feedback ()
     ;;   "Show line numbers temporarily, while prompting for the line number input"
     ;;   (interactive)
     ;;   (unwind-protect
     ;;       (progn
     ;;         (linum-mode 1)
     ;;         (goto-line (read-number "Goto line: ")))
     ;;     (linum-mode -1)))

     ;; ;(global-set-key [remap goto-line] 'goto-line-with-feedback)
     ;; (setq linum-format 'linum-relativenumber-format)
   #+END_SRC

   #+RESULTS: linum-relative
   : linum-relativenumber-format

** Don't kill emacs by accident
   #+NAME: emacs-no-kill
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun dont-kill-emacs ()
       (interactive)
       (error (substitute-command-keys "To exit emacs: \\[kill-emacs]")))
     (global-set-key "\C-x\C-c" 'dont-kill-emacs)
     (global-set-key (kbd "C-x r q") 'save-buffers-kill-terminal)
   #+END_SRC

   #+RESULTS: emacs-no-kill
   : save-buffers-kill-terminal

** Backups
   #+NAME: backups
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq vc-make-backup-files t)
     (setq backup-directory-alist
           `(("." . ,(expand-file-name
                      (concat user-emacs-directory ".backups")))))
   #+END_SRC

   #+RESULTS: backups
   | (. . /home/sizur/.emacs.d/.backups) |
   
** Remember position
   #+NAME: remem-pos
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'saveplace)
     (setq-default save-place t)
     (setq save-place-file (expand-file-name ".places" user-emacs-directory))
   #+END_SRC

   #+RESULTS: remem-pos
   : /home/sizur/.emacs.d/.places  
* Autoload at start
  #+NAME: emacs-at-start
  #+BEGIN_SRC emacs-lisp :tangle yes
    (server-start)
    (require 'org-protocol)
    (org-agenda-list)
    (global-company-mode)
  #+END_SRC

  #+RESULTS: emacs-at-start

